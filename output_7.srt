1
00:00:00,330 --> 00:00:04,190
We'll save it into an ingress configuration file. So let's see what options

2
00:00:04,260 --> 00:00:07,486
we have here. We have ingress name,

3
00:00:07,588 --> 00:00:11,962
let's call it nginx, or let's call it Myapp

4
00:00:12,106 --> 00:00:15,694
ingress. And I'm just going to

5
00:00:15,732 --> 00:00:19,166
copy this and we're going to do the

6
00:00:19,188 --> 00:00:24,190
actual configuration in the file. So dry run client

7
00:00:25,370 --> 00:00:29,270
Yaml and let's save it into my ingress

8
00:00:29,770 --> 00:00:31,430
Yaml file.

9
00:00:34,010 --> 00:00:38,214
I'm going to clean up the unnecessary data here

10
00:00:38,332 --> 00:00:41,386
and let's see what we have. And you see this is a

11
00:00:41,408 --> 00:00:44,486
super basic ingress configuration file,

12
00:00:44,598 --> 00:00:48,358
and you already learned the structure of ingress file

13
00:00:48,454 --> 00:00:52,510
and these are basically the attributes. Now note one thing here,

14
00:00:52,580 --> 00:00:56,186
which is some of the attribute names actually changed

15
00:00:56,218 --> 00:00:59,774
in the recent version of Kubernetes. So you may

16
00:00:59,812 --> 00:01:03,658
see ingress configuration files with attributes like

17
00:01:03,764 --> 00:01:07,390
service name and service port, which doesn't work anymore

18
00:01:07,470 --> 00:01:10,802
because this is the new attribute list.

19
00:01:10,936 --> 00:01:14,382
So just to be aware, in case you see an ingress configuration

20
00:01:14,446 --> 00:01:18,226
file which has service name and service port attribute

21
00:01:18,258 --> 00:01:21,926
names. So what we need to configure here is that whenever a

22
00:01:21,948 --> 00:01:25,286
request comes to the load balancer on

23
00:01:25,388 --> 00:01:29,346
the load balancer's URL, which is the host,

24
00:01:29,458 --> 00:01:33,318
and let's go see what is the host of the load balancer.

25
00:01:33,414 --> 00:01:36,954
It is actually the DNS name. Now you could map it to

26
00:01:36,992 --> 00:01:40,394
your own domain name, like myapp.com. In our

27
00:01:40,432 --> 00:01:43,022
case, we just have load balancer's domain name.

28
00:01:43,156 --> 00:01:46,686
Note that this cannot be an IP address, it actually has to be a

29
00:01:46,708 --> 00:01:50,346
domain name. So we're going to use load balancer's domain

30
00:01:50,378 --> 00:01:54,482
name, this long domain name that load balancer has

31
00:01:54,616 --> 00:01:58,274
automatically assigned from AWS, and we're going to use

32
00:01:58,312 --> 00:02:01,186
it as the host. That means again,

33
00:02:01,368 --> 00:02:04,866
whenever a request comes to the

34
00:02:04,888 --> 00:02:08,614
load balancer on the HTTP port, we want

35
00:02:08,652 --> 00:02:11,714
to define what happens to that request.

36
00:02:11,842 --> 00:02:15,634
And we're going to say that we want that request to be forwarded

37
00:02:15,762 --> 00:02:19,914
to our internal service called

38
00:02:20,032 --> 00:02:22,380
NgInX service,

39
00:02:23,550 --> 00:02:27,210
on the port of NgInX service.

40
00:02:27,360 --> 00:02:31,082
So some services have named ports.

41
00:02:31,226 --> 00:02:34,720
In our case we can just specify a number of the port,

42
00:02:35,410 --> 00:02:38,686
which is 80, 80. And finally

43
00:02:38,868 --> 00:02:42,414
we have path, which basically adds to

44
00:02:42,452 --> 00:02:46,082
the URL right here. So the combination of the

45
00:02:46,136 --> 00:02:50,114
host and the path will basically mean that we want to configure an

46
00:02:50,152 --> 00:02:53,810
ingress routing rule for this domain and

47
00:02:53,960 --> 00:02:57,686
path like this for this URL. Basically in

48
00:02:57,708 --> 00:03:01,974
our case, however, we want to create a rule for a

49
00:03:02,012 --> 00:03:06,070
root path. So basically this domain name directly without

50
00:03:06,140 --> 00:03:09,654
any edit path and path type is exact.

51
00:03:09,772 --> 00:03:13,146
So this is going to match the path we defined here

52
00:03:13,248 --> 00:03:17,146
exactly, which means with path type you can actually define prefix of

53
00:03:17,168 --> 00:03:20,586
the path, for example. But let's leave our configuration at

54
00:03:20,608 --> 00:03:24,574
this simple rule. Let's actually remove the

55
00:03:24,612 --> 00:03:27,786
HTTP part here. And now let's

56
00:03:27,818 --> 00:03:31,390
apply our ingress file. And here we have an error

57
00:03:31,810 --> 00:03:35,934
that one of the services which is Ingress NginX

58
00:03:35,982 --> 00:03:40,414
controller admission service with this IP address cannot

59
00:03:40,462 --> 00:03:44,782
be connected with an internal error that a webhook

60
00:03:44,846 --> 00:03:48,018
validation failed. And you may also have this error.

61
00:03:48,114 --> 00:03:51,554
We're going to try to fix that with a simple workaround

62
00:03:51,682 --> 00:03:55,366
because I don't want to go into too much detail here. So if

63
00:03:55,388 --> 00:03:59,174
you do Kubectl get validating webhook

64
00:03:59,222 --> 00:04:02,474
configuration, which is a

65
00:04:02,512 --> 00:04:05,782
custom resource, basically this is not a Kubernetes

66
00:04:05,846 --> 00:04:09,942
native resource, but rather part of the ingress Nginx

67
00:04:10,086 --> 00:04:13,626
that we deployed. If we do Kubectl get validating webhook

68
00:04:13,658 --> 00:04:16,426
configuration, we see this one resource.

69
00:04:16,538 --> 00:04:20,302
Now we don't have to understand what this is and what it does. It is

70
00:04:20,356 --> 00:04:23,406
in familiar kubernetes manifest file

71
00:04:23,438 --> 00:04:27,042
format. All we have to do is change

72
00:04:27,176 --> 00:04:31,634
one value here to

73
00:04:31,672 --> 00:04:35,086
basically fix our problem. And if I scroll down here we

74
00:04:35,128 --> 00:04:38,466
have an attribute called failure policy and we're

75
00:04:38,498 --> 00:04:40,550
going to set it to ignore.

76
00:04:41,930 --> 00:04:45,462
Save this. You see that webhook configuration was

77
00:04:45,516 --> 00:04:49,570
edited and now let's actually try to apply ingress

78
00:04:49,650 --> 00:04:53,002
again. So basically we just worked around the issue.

79
00:04:53,056 --> 00:04:56,378
It's not fixed, which is a specific ingress issue.

80
00:04:56,464 --> 00:05:00,022
And since we don't want to go too much into detail and fix that,

81
00:05:00,096 --> 00:05:04,266
we're just going to disable it. And now we're able to create ingress

82
00:05:04,378 --> 00:05:08,590
resource in the cluster. So how do we check ingress resources?

83
00:05:09,090 --> 00:05:12,974
Kubectl get Ingress command

84
00:05:13,022 --> 00:05:16,510
will list us all the available ingress configurations

85
00:05:16,590 --> 00:05:19,266
basically in the cluster. And remember,

86
00:05:19,368 --> 00:05:23,182
ingress is a namespaced resource.

87
00:05:23,326 --> 00:05:27,058
So we're seeing ingresses in default namespace.

88
00:05:27,154 --> 00:05:31,014
And also note that we created ingress component in the same

89
00:05:31,052 --> 00:05:34,786
namespace as the service to which we are forwarding

90
00:05:34,818 --> 00:05:39,526
the request to. So now if everything was configured properly

91
00:05:39,718 --> 00:05:43,180
using this host address right here,

92
00:05:43,550 --> 00:05:47,558
we should be able to access our NginX service. So I'm

93
00:05:47,574 --> 00:05:50,926
going to copy that. And this is actually the same

94
00:05:51,028 --> 00:05:54,474
load balancer name we used before and reload

95
00:05:54,522 --> 00:05:58,746
again. And there you go, we have ingress

96
00:05:58,938 --> 00:06:02,726
configuration that tells ingress controller

97
00:06:02,778 --> 00:06:06,482
application that whenever this endpoint gets

98
00:06:06,536 --> 00:06:09,950
hit in the browser, please forward that request

99
00:06:10,110 --> 00:06:13,666
to the NgInX service. And we see the

100
00:06:13,688 --> 00:06:15,540
NgInX welcome page here.

101
00:06:18,170 --> 00:06:21,538
Now of course if you have multiple applications in the cluster

102
00:06:21,634 --> 00:06:24,726
and you want all of them to be accessible through

103
00:06:24,828 --> 00:06:28,426
the same host, but on different path. Then you

104
00:06:28,448 --> 00:06:32,326
can make each application available on a certain path.

105
00:06:32,438 --> 00:06:35,866
So let's see that configuration as well. Going back to the

106
00:06:35,888 --> 00:06:39,158
cluster, I'm actually going to delete our existing

107
00:06:39,254 --> 00:06:40,010
ingress,

108
00:06:42,670 --> 00:06:48,494
and we are going to adjust the

109
00:06:48,532 --> 00:06:50,030
ingress configuration.

110
00:06:51,330 --> 00:06:54,722
And what we're going to do is we're going to say

111
00:06:54,856 --> 00:06:59,026
whenever a request comes to this host on a path called

112
00:06:59,128 --> 00:07:02,238
my app, on exactly this path,

113
00:07:02,334 --> 00:07:05,862
forward that request to the NgInX service. So again,

114
00:07:05,996 --> 00:07:09,974
let's save the change, apply the

115
00:07:10,012 --> 00:07:13,746
ingress configuration, and let's

116
00:07:13,778 --> 00:07:17,554
check our ingress again. Let's actually describe the ingress so

117
00:07:17,612 --> 00:07:21,254
that we can see the configured

118
00:07:21,382 --> 00:07:23,900
rules in a human readable way.

119
00:07:25,790 --> 00:07:28,774
Right here we have the host, we have the path,

120
00:07:28,902 --> 00:07:32,414
and we have the configured backend for that

121
00:07:32,452 --> 00:07:36,350
URL. So now if we refresh the page on

122
00:07:36,420 --> 00:07:40,350
the root destination without

123
00:07:40,420 --> 00:07:44,194
any path, we're going to get bed gateway because nothing

124
00:07:44,312 --> 00:07:47,934
or no backend is configured for a root

125
00:07:47,982 --> 00:07:51,282
path. Right? Backend here is empty only

126
00:07:51,336 --> 00:07:55,630
for myApp. Now let's try with MyApp URL.

127
00:07:55,790 --> 00:07:59,526
And as you see, we actually get not found, which means we

128
00:07:59,548 --> 00:08:02,870
were able to access NgInX. So the traffic routing actually

129
00:08:02,940 --> 00:08:06,662
worked. We reached NgINX service and

130
00:08:06,716 --> 00:08:09,978
the pods behind. But when Nginx got

131
00:08:09,984 --> 00:08:13,686
the request, it actually got a request on MyEp.

132
00:08:13,798 --> 00:08:18,230
And Nginx doesn't know what to do with that myapath

133
00:08:18,310 --> 00:08:22,366
because it doesn't expect such a path. So what we

134
00:08:22,468 --> 00:08:25,870
need to do here is we need to tell

135
00:08:26,020 --> 00:08:30,042
Ingress to forward the request

136
00:08:30,186 --> 00:08:33,306
coming to this host to this path.

137
00:08:33,418 --> 00:08:36,498
But when it forwards that request to the service,

138
00:08:36,584 --> 00:08:40,398
Nginx service, we want it to remove the myapp path.

139
00:08:40,494 --> 00:08:44,286
So basically we just want the request to go directly

140
00:08:44,398 --> 00:08:48,642
to the NgINX service without the myApp path, because NginX

141
00:08:48,786 --> 00:08:52,530
does not expect such a path, it just expects a root path.

142
00:08:52,610 --> 00:08:56,946
So how do we tell Ingress to remove the path when sending

143
00:08:56,978 --> 00:09:00,682
the request further to the service? Well, there is

144
00:09:00,736 --> 00:09:04,902
actually on configuration for that which goes into metadata

145
00:09:05,046 --> 00:09:09,494
and looks like this, it's an annotations attribute and the configuration

146
00:09:09,542 --> 00:09:14,154
is actually called rewrite target. So we are rewriting

147
00:09:14,282 --> 00:09:17,982
the request before it reaches the

148
00:09:18,116 --> 00:09:22,422
target service. And that's how the rewrite target configuration

149
00:09:22,506 --> 00:09:26,462
looks like. So we're going to copy it into our configuration

150
00:09:26,526 --> 00:09:29,922
file and

151
00:09:29,976 --> 00:09:33,454
we're going to tell Ingress to rewrite

152
00:09:33,582 --> 00:09:37,058
target to root path. So it's going

153
00:09:37,064 --> 00:09:40,274
to rewrite the path from my

154
00:09:40,312 --> 00:09:43,814
app to simply slash. So let's try this

155
00:09:43,852 --> 00:09:47,238
out. I'm going to apply the configuration changes to

156
00:09:47,244 --> 00:09:50,534
the existing ingress, and let's go

157
00:09:50,572 --> 00:09:53,738
ahead and type Myapp in the browser again.

158
00:09:53,904 --> 00:09:57,450
And this should actually show us

159
00:09:57,520 --> 00:10:02,090
welcome to Nginx page. So that's how we can access applications

160
00:10:02,170 --> 00:10:06,266
in the cluster on certain path. So we can have Nginx

161
00:10:06,378 --> 00:10:09,774
service accessible on my app, we can have

162
00:10:09,892 --> 00:10:13,314
maybe a database UI accessible at

163
00:10:13,512 --> 00:10:16,626
my database and so on, and we can

164
00:10:16,648 --> 00:10:20,222
configure all of that using simple ingress

165
00:10:20,286 --> 00:10:21,250
configuration.

166
00:10:24,150 --> 00:10:27,442
Now just a couple of notes here on Ingress and Ingress

167
00:10:27,506 --> 00:10:30,486
controller manager before we wrap this up.

168
00:10:30,588 --> 00:10:33,926
First of all, you notice that we have

169
00:10:34,028 --> 00:10:37,686
just one single ingress controller pod running in

170
00:10:37,708 --> 00:10:41,514
the cluster. Of course, in a production environment this is not very

171
00:10:41,552 --> 00:10:45,126
optimal because you are dependent on one single replica.

172
00:10:45,238 --> 00:10:48,534
So ideally you should have one replica

173
00:10:48,582 --> 00:10:52,362
of Ingress controller pod per worker node,

174
00:10:52,426 --> 00:10:56,570
so each worker node having its own ingress controller pod.

175
00:10:56,650 --> 00:11:00,078
Another note on Ingress configuration itself is that

176
00:11:00,164 --> 00:11:03,674
you can actually configure multiple different routes here.

177
00:11:03,812 --> 00:11:07,554
So if you have ten applications and you want to

178
00:11:07,592 --> 00:11:11,310
configure routes to all of them based on the path,

179
00:11:11,390 --> 00:11:14,642
you can actually configure all of those right here

180
00:11:14,776 --> 00:11:18,354
and have the same rewrite target annotation

181
00:11:18,482 --> 00:11:22,454
for all of them, which basically removes the path that we just

182
00:11:22,492 --> 00:11:26,198
came up with and sends a request to the service

183
00:11:26,364 --> 00:11:30,422
on a normal standard endpoint there. And optionally

184
00:11:30,486 --> 00:11:34,970
you can have a separate ingress component for each service.

185
00:11:35,120 --> 00:11:39,100
And that's how you configure ingress for application

186
00:11:39,550 --> 00:12:05,724
routing in your cluster and

187
00:12:05,762 --> 00:12:09,276
set up for developers. It's time to give them access to

188
00:12:09,298 --> 00:12:13,276
the cluster. But what kind of access do we want to give them? What kind

189
00:12:13,298 --> 00:12:17,164
of permissions should they be able to do anything in the cluster?

190
00:12:17,292 --> 00:12:20,560
What if they destroy some stuff? We don't want to just give

191
00:12:20,630 --> 00:12:23,936
everyone an admin user access, right? So we need

192
00:12:23,958 --> 00:12:27,680
to create users for the developers with limited

193
00:12:27,760 --> 00:12:31,764
permissions. For that, let's first understand how users and

194
00:12:31,802 --> 00:12:34,260
permissions work in Kubernetes.

195
00:12:51,560 --> 00:12:55,716
Authentication and authorization works in Kubernetes,

196
00:12:55,908 --> 00:12:59,032
how you can configure users groups and their

197
00:12:59,086 --> 00:13:02,488
permissions in the cluster, and you will learn about

198
00:13:02,574 --> 00:13:06,196
role based access control or RBEC concept

199
00:13:06,308 --> 00:13:10,072
and which Kubernetes resources we use to define

200
00:13:10,136 --> 00:13:13,660
permissions in the cluster. So let's start by

201
00:13:13,730 --> 00:13:17,116
understanding why do we need to manage permissions in

202
00:13:17,138 --> 00:13:20,784
the Kubernetes cluster in the first place. You have

203
00:13:20,822 --> 00:13:24,960
a Kubernetes cluster that Kubernetes admins are

204
00:13:25,030 --> 00:13:29,100
administering and developer teams are deploying resources

205
00:13:29,180 --> 00:13:32,616
into now how do we manage permissions

206
00:13:32,748 --> 00:13:36,996
for the cluster? Because administrators need different access

207
00:13:37,098 --> 00:13:40,452
than developers, right? Developers should be limited to

208
00:13:40,506 --> 00:13:44,052
what they can do in the cluster so that they don't break

209
00:13:44,106 --> 00:13:47,784
stuff accidentally, while admins should be able

210
00:13:47,822 --> 00:13:51,508
to administer the cluster. In security best practices,

211
00:13:51,604 --> 00:13:54,676
we have the least privilege rule,

212
00:13:54,788 --> 00:13:58,124
which means we give every user only the

213
00:13:58,162 --> 00:14:01,816
permissions they need, not more. So let's

214
00:14:01,848 --> 00:14:03,420
start with developers.

215
00:14:06,400 --> 00:14:10,244
Let's say you have multiple namespaces in the cluster

216
00:14:10,392 --> 00:14:14,096
and each developer team deploys their application in

217
00:14:14,118 --> 00:14:17,296
the different namespace. How do you make sure

218
00:14:17,398 --> 00:14:21,456
each team gets access to only their namespace and the

219
00:14:21,478 --> 00:14:25,760
resources in that namespace so they don't accidentally

220
00:14:25,840 --> 00:14:29,504
break something in the namespaces of other teams?

221
00:14:29,632 --> 00:14:32,864
For this we have what's called RBEC in Kubernetes,

222
00:14:32,992 --> 00:14:36,316
RBaC, which stands for role

223
00:14:36,368 --> 00:14:39,736
based access control. So let's see how

224
00:14:39,758 --> 00:14:43,252
that works. With RBEC you can define

225
00:14:43,316 --> 00:14:47,108
access to each namespace using

226
00:14:47,294 --> 00:14:50,796
roles. So role is bound to a specific

227
00:14:50,898 --> 00:14:54,684
namespace and defines what resources in that

228
00:14:54,722 --> 00:14:58,552
namespace you can access where resource is a pod,

229
00:14:58,616 --> 00:15:02,252
deployment, service, secret, et cetera.

230
00:15:02,396 --> 00:15:06,252
And what you can do with these resources,

231
00:15:06,396 --> 00:15:09,420
like list, read these resources,

232
00:15:09,500 --> 00:15:13,540
edit, delete, et cetera. So for each developer team,

233
00:15:13,610 --> 00:15:17,536
you can create a role for their specific namespace

234
00:15:17,728 --> 00:15:21,108
that they are managing and define what they can do inside

235
00:15:21,194 --> 00:15:25,384
that namespace. Maybe they can only create stuff, but they

236
00:15:25,422 --> 00:15:29,604
cannot delete any resources. But role only defines

237
00:15:29,652 --> 00:15:33,492
the resources and access permission to those resources.

238
00:15:33,636 --> 00:15:37,732
It doesn't include information about who gets that access

239
00:15:37,886 --> 00:15:41,464
defined in the role. So how do we attach role

240
00:15:41,512 --> 00:15:45,276
definition to a developer team for that? We have

241
00:15:45,378 --> 00:15:49,432
another component in Kubernetes called role binding,

242
00:15:49,576 --> 00:15:52,956
which is a very simple concept. Basically with role

243
00:15:52,988 --> 00:15:56,608
binding we simply link a role to

244
00:15:56,694 --> 00:16:00,480
a user or user group. So we can create

245
00:16:00,550 --> 00:16:03,908
users and bind the role to each user using

246
00:16:03,994 --> 00:16:08,016
role binding. But if you have ten developers

247
00:16:08,128 --> 00:16:11,668
in a team that all need the same permission, you can instead

248
00:16:11,754 --> 00:16:15,316
create dev team group with all the

249
00:16:15,338 --> 00:16:19,672
users and then bind the role to that group instead

250
00:16:19,726 --> 00:16:23,272
of binding that to each user separately. And with

251
00:16:23,326 --> 00:16:26,536
role binding, all the members in this group will get

252
00:16:26,558 --> 00:16:30,488
the permission in the cluster to do whatever is defined

253
00:16:30,584 --> 00:16:31,740
in the role.

254
00:16:34,750 --> 00:16:39,030
Now what about administrators? Kubernetes administrators

255
00:16:39,110 --> 00:16:42,618
obviously are the ones that are administering the cluster.

256
00:16:42,794 --> 00:16:45,338
They are managing all the namespaces,

257
00:16:45,514 --> 00:16:49,502
configuring the volumes for the developer teams that are available

258
00:16:49,636 --> 00:16:53,150
cluster wide, et cetera. So they are doing

259
00:16:53,220 --> 00:16:56,578
cluster wide operations. So how do

260
00:16:56,584 --> 00:17:00,286
we define their permissions? In Kubernetes, role doesn't

261
00:17:00,318 --> 00:17:04,002
work here because role is limited to a namespace and

262
00:17:04,056 --> 00:17:07,000
admins, as we just said, need cluster wide access.

263
00:17:07,530 --> 00:17:11,538
Well, for that we have another component from RBEC

264
00:17:11,634 --> 00:17:15,510
which is cluster role. Cluster role defines what

265
00:17:15,580 --> 00:17:18,242
resources have what permissions,

266
00:17:18,386 --> 00:17:21,770
but cluster wide instead of limited to a

267
00:17:21,840 --> 00:17:25,306
specific namespace. So for the admins we

268
00:17:25,328 --> 00:17:28,698
would create a cluster role, an admin group,

269
00:17:28,784 --> 00:17:32,526
and then attach the cluster role to the admin group using a

270
00:17:32,548 --> 00:17:34,590
cluster role binding.

271
00:17:37,170 --> 00:17:40,686
Now there is one important question here, which is how

272
00:17:40,708 --> 00:17:43,950
do we create users or groups in Kubernetes

273
00:17:44,030 --> 00:17:47,714
that we can then assign role or cluster role to?

274
00:17:47,832 --> 00:17:51,282
Well, Kubernetes itself doesn't actually provide any

275
00:17:51,336 --> 00:17:55,154
resources or a specific way of creating and

276
00:17:55,192 --> 00:17:59,570
managing users and groups. It just gives us an interface

277
00:17:59,650 --> 00:18:03,254
and flexibility to do it in many different ways.

278
00:18:03,452 --> 00:18:07,190
So basically, user or user group concept or

279
00:18:07,260 --> 00:18:10,854
resource in Kubernetes doesn't exist. So it relies

280
00:18:10,902 --> 00:18:14,774
on external sources for creating and managing users

281
00:18:14,822 --> 00:18:18,314
and groups. And this external source could be a

282
00:18:18,352 --> 00:18:21,550
static file with user details, username and

283
00:18:21,620 --> 00:18:25,294
token. It could also be certificates that

284
00:18:25,332 --> 00:18:28,842
are assigned by Kubernetes itself or a third party

285
00:18:28,906 --> 00:18:33,270
identity service like LDEP for example. So a Kubernetes

286
00:18:33,370 --> 00:18:36,994
administrator will usually configure one

287
00:18:37,032 --> 00:18:40,782
of these external sources like static

288
00:18:40,846 --> 00:18:44,898
file or certificate or third party identity service in

289
00:18:44,904 --> 00:18:48,294
the cluster so that Kubernetes has access to this

290
00:18:48,332 --> 00:18:52,182
information. And then API server, which is one of the control

291
00:18:52,236 --> 00:18:55,830
plane components of Kubernetes and which is the one

292
00:18:55,900 --> 00:18:59,498
handling authentication of all the requests coming

293
00:18:59,584 --> 00:19:03,590
in. Kubernetes cluster will try to authenticate

294
00:19:03,670 --> 00:19:07,786
any user that is trying to connect to the cluster using

295
00:19:07,968 --> 00:19:11,694
one of these configured sources. So these

296
00:19:11,732 --> 00:19:15,114
are examples of token files for defining users.

297
00:19:15,242 --> 00:19:18,894
You can pass these files to API server so

298
00:19:18,932 --> 00:19:22,734
that API server knows where to look up the user information

299
00:19:22,932 --> 00:19:26,610
to authenticate users when they try to connect

300
00:19:26,680 --> 00:19:30,114
to the cluster. If you want to define groups that

301
00:19:30,152 --> 00:19:33,774
users belong to, you can simply add a group column

302
00:19:33,822 --> 00:19:38,054
in this users file in this static file and

303
00:19:38,092 --> 00:19:41,366
this will give you users and groups in the

304
00:19:41,388 --> 00:19:45,010
cluster. For certificates. You as an admin

305
00:19:45,090 --> 00:19:49,106
will have to manually create certificates for different users

306
00:19:49,218 --> 00:19:52,714
in your team. This will be the users that will

307
00:19:52,752 --> 00:19:56,394
be allowed to connect to the cluster. Or as I said

308
00:19:56,432 --> 00:20:00,230
as a Kubernetes admin, you will have to configure LDAP

309
00:20:00,310 --> 00:20:04,350
as an authentication source for the API server.

310
00:20:04,770 --> 00:20:08,446
So as I mentioned at the beginning, Kubernetes allows you

311
00:20:08,468 --> 00:20:12,170
to configure these external sources for authentication,

312
00:20:12,330 --> 00:20:15,474
but it doesn't manage them itself. You have to

313
00:20:15,512 --> 00:20:18,930
manage them yourself as a Kubernetes administrator.

314
00:20:22,290 --> 00:20:25,854
Great, so we gave our admins privilege to

315
00:20:25,892 --> 00:20:30,366
administer the cluster using cluster role and limited permissions

316
00:20:30,478 --> 00:20:34,402
to our developer teams so that each can manage only

317
00:20:34,456 --> 00:20:39,054
their namespace and resources inside using roles.

318
00:20:39,182 --> 00:20:42,422
So these human user permissions are taken

319
00:20:42,476 --> 00:20:46,706
care of. Now what about application users?

320
00:20:46,898 --> 00:20:49,922
Not only people have access to the cluster,

321
00:20:50,066 --> 00:20:53,722
applications and services also access

322
00:20:53,776 --> 00:20:57,654
the cluster. These applications can be internal

323
00:20:57,782 --> 00:21:01,302
inside the cluster or outside the cluster.

324
00:21:01,446 --> 00:21:05,278
For example, inside the cluster we may have a monitoring application

325
00:21:05,364 --> 00:21:09,642
like Prometheus that needs access to all other applications

326
00:21:09,786 --> 00:21:13,502
to collect metrics from them. And we also may have

327
00:21:13,636 --> 00:21:17,094
microservices applications that only need resources

328
00:21:17,242 --> 00:21:20,386
and access to resources within their specific

329
00:21:20,488 --> 00:21:23,762
namespace. These applications are running

330
00:21:23,816 --> 00:21:28,526
inside the cluster and are talking to other applications

331
00:21:28,718 --> 00:21:31,830
or using other resources in the cluster.

332
00:21:32,250 --> 00:21:35,782
And we also have the external applications, for example

333
00:21:35,916 --> 00:21:39,986
a CI CD tool that deploys applications to the cluster,

334
00:21:40,098 --> 00:21:43,754
or maybe a terraform application that configures the

335
00:21:43,792 --> 00:21:47,194
cluster itself. As I said at the beginning with

336
00:21:47,232 --> 00:21:50,182
the least privileges security practice,

337
00:21:50,326 --> 00:21:54,102
we want to make sure the application only has permissions

338
00:21:54,166 --> 00:21:57,934
that it needs in the cluster and not more.

339
00:21:58,132 --> 00:22:01,866
So how do we define permissions for application users

340
00:22:01,978 --> 00:22:05,934
in Kubernetes cluster? For that we actually have

341
00:22:05,972 --> 00:22:09,602
a Kubernetes resource that represents an

342
00:22:09,656 --> 00:22:13,182
application user, and this Kubernetes component

343
00:22:13,246 --> 00:22:17,234
is called service account. So instead of user or

344
00:22:17,272 --> 00:22:20,470
a group for human users, you create a service

345
00:22:20,540 --> 00:22:24,374
component for the application user. So your application

346
00:22:24,572 --> 00:22:27,986
like metric server, Prometheus or external CI

347
00:22:28,018 --> 00:22:32,098
CD tool like Jenkins will get a service account

348
00:22:32,204 --> 00:22:36,038
component inside the cluster as a representation

349
00:22:36,134 --> 00:22:39,594
of that application's user. And the same

350
00:22:39,632 --> 00:22:43,418
way as for human users, you can link

351
00:22:43,584 --> 00:22:47,194
service account to a role or cluster

352
00:22:47,242 --> 00:22:51,018
role with role binding or cluster role binding

353
00:22:51,114 --> 00:22:54,282
component, and with binding

354
00:22:54,426 --> 00:22:58,386
service account. Or the application user that is behind that

355
00:22:58,408 --> 00:23:01,774
service account will get permissions that are defined

356
00:23:01,822 --> 00:23:04,210
in the role or cluster role.

357
00:23:05,030 --> 00:23:08,834
Now let's see what the Kubernetes configuration files actually look

358
00:23:08,872 --> 00:23:12,774
like for all these components. First of all,

359
00:23:12,812 --> 00:23:16,354
this is an example of a role configuration file

360
00:23:16,482 --> 00:23:20,342
where we define what resources have what kind of

361
00:23:20,396 --> 00:23:24,650
access. So in each role we have three sections

362
00:23:25,070 --> 00:23:28,810
API group. The default one is

363
00:23:28,880 --> 00:23:32,186
the core API group. So when using the

364
00:23:32,208 --> 00:23:36,778
core API group you can leave it empty for others. We have to specify

365
00:23:36,954 --> 00:23:41,550
then within that API group we have resources like

366
00:23:41,700 --> 00:23:44,350
pod deployment, et cetera,

367
00:23:44,690 --> 00:23:48,594
which are part of the defined API group. And then we have

368
00:23:48,632 --> 00:23:53,234
as a third part access verbs like list,

369
00:23:53,352 --> 00:23:57,266
create, delete, update, etc. That applies to

370
00:23:57,288 --> 00:24:00,180
the resources in the defined API group.

371
00:24:00,570 --> 00:24:03,538
This role is for a default namespace,

372
00:24:03,714 --> 00:24:07,906
but if you want to give access to the defined resources

373
00:24:08,018 --> 00:24:12,146
for namespace Myapp, you will add a namespace myapp

374
00:24:12,178 --> 00:24:15,546
in the metadata of role. That's how you

375
00:24:15,568 --> 00:24:19,050
can scope the role to a specific namespace.

376
00:24:19,390 --> 00:24:22,502
You can also set access to resources

377
00:24:22,566 --> 00:24:26,430
even more granularly. For example, instead of giving access to

378
00:24:26,500 --> 00:24:30,062
all the pods in that namespace, you can define access to

379
00:24:30,116 --> 00:24:33,866
only certain pods in that namespace using resource

380
00:24:33,978 --> 00:24:37,986
name attribute. For example, if in the same namespace you

381
00:24:38,008 --> 00:24:41,474
have your own application and maybe a

382
00:24:41,512 --> 00:24:45,230
database, and you want to basically define

383
00:24:45,390 --> 00:24:49,154
separate roles in the same namespace, but for

384
00:24:49,272 --> 00:24:53,254
your own application and for database basically separately as

385
00:24:53,292 --> 00:24:56,918
different roles, you can target these specific

386
00:24:57,004 --> 00:25:01,270
pods or applications using the resource name attribute

387
00:25:01,610 --> 00:25:04,982
and then define different privileges on those resources,

388
00:25:05,126 --> 00:25:08,858
and then you have a role binding for that role to

389
00:25:08,944 --> 00:25:13,034
then attach it to a user group

390
00:25:13,152 --> 00:25:16,746
or a service account. Here you define

391
00:25:16,778 --> 00:25:20,206
a cluster role for node, which is

392
00:25:20,228 --> 00:25:23,598
a cluster wide resource. So you can basically define for the

393
00:25:23,604 --> 00:25:27,386
Kubernetes administrators what privileges they

394
00:25:27,428 --> 00:25:31,454
have on worker nodes, right? Or you can also define cluster role

395
00:25:31,502 --> 00:25:35,474
for namespace management, since namespace is also a

396
00:25:35,512 --> 00:25:39,294
cluster wide resource. But in addition

397
00:25:39,342 --> 00:25:43,410
to defining permissions for cluster wide resources

398
00:25:43,490 --> 00:25:48,034
in cluster role, you can also define cluster role for namespaced

399
00:25:48,082 --> 00:25:51,122
resources like pods services, deployments,

400
00:25:51,186 --> 00:25:54,986
et cetera, just like in the role. And if you define a

401
00:25:55,008 --> 00:25:58,330
cluster role with pod access, it will mean access

402
00:25:58,400 --> 00:26:02,506
to pods in all namespaces, not just one specific one as in

403
00:26:02,528 --> 00:26:06,666
the role and in cluster role binding. You will then link that cluster

404
00:26:06,698 --> 00:26:09,822
role again to a user group or

405
00:26:09,876 --> 00:26:11,040
a service account.

406
00:26:13,650 --> 00:26:17,178
And since are defined as Kubernetes manifest

407
00:26:17,274 --> 00:26:20,510
files, you can create these components in Kubernetes cluster

408
00:26:20,590 --> 00:26:24,030
just like you create any other components like pods

409
00:26:24,110 --> 00:26:27,506
services, config maps, et cetera, and you can

410
00:26:27,528 --> 00:26:31,010
also view them using Kubectl get or describe

411
00:26:31,090 --> 00:26:34,498
commands. Another interesting and useful

412
00:26:34,674 --> 00:26:38,390
thing is that you can actually check the privileges

413
00:26:38,890 --> 00:26:42,862
that your current user has using Kubectl

414
00:26:42,946 --> 00:26:46,938
auth command. If you're an admin, you can also check access

415
00:26:47,024 --> 00:26:50,154
or privileges of any other users in the

416
00:26:50,192 --> 00:26:53,542
cluster to see who has what permissions

417
00:26:53,686 --> 00:26:57,850
in any namespace. And this could be a very useful

418
00:26:57,930 --> 00:27:01,726
and convenient way to look up permissions that you have

419
00:27:01,828 --> 00:27:05,994
basically given to different users inside your cluster.

420
00:27:06,122 --> 00:27:10,020
So to wrap this whole thing up in Kubernetes security,

421
00:27:10,390 --> 00:27:13,406
we have two different levels.

422
00:27:13,598 --> 00:27:17,102
For example, Jenkins sends a request

423
00:27:17,166 --> 00:27:21,414
to the API server that it wants to create

424
00:27:21,532 --> 00:27:25,426
a new service in a default namespace.

425
00:27:25,618 --> 00:27:29,490
On the first level, API server will authenticate

426
00:27:29,570 --> 00:27:33,210
the user, human or application user, in this case

427
00:27:33,280 --> 00:27:37,402
Jenkins in the cluster, to see

428
00:27:37,536 --> 00:27:41,334
whether this application Jenkins is allowed

429
00:27:41,382 --> 00:27:45,042
to connect to the cluster. Can this user access the cluster

430
00:27:45,126 --> 00:27:49,022
at all? Does it have access credentials like username, password or

431
00:27:49,076 --> 00:27:52,542
certificate to talk to the cluster if

432
00:27:52,596 --> 00:27:56,542
authenticated? As the second step, Kubernetes will check the

433
00:27:56,596 --> 00:28:00,562
authorization of that authenticated user using

434
00:28:00,696 --> 00:28:04,274
RBEC. So we check what role or cluster role that

435
00:28:04,312 --> 00:28:08,126
user has and based on that permission defined

436
00:28:08,158 --> 00:28:12,022
there, does user have permission to perform this

437
00:28:12,076 --> 00:28:16,194
specific task that it's trying to perform? So that's

438
00:28:16,242 --> 00:28:19,494
how authentication and authorization in

439
00:28:19,532 --> 00:28:23,862
Kubernetes looks like and how Kubernetes uses RBEC

440
00:28:23,926 --> 00:28:28,282
and its components to manage authorization of

441
00:28:28,336 --> 00:28:31,770
who is allowed to do what inside the cluster.

442
00:28:34,110 --> 00:28:37,950
Now I have to note here that RBEC is actually one of

443
00:28:38,100 --> 00:28:42,410
four ways of authorizing users or applications in Kubernetes.

444
00:28:42,570 --> 00:28:46,266
Kubernetes supports four different authorization modes

445
00:28:46,378 --> 00:28:50,258
such as Node EREC or attribute based

446
00:28:50,344 --> 00:28:54,062
access control, RBEC and Webhook.

447
00:28:54,126 --> 00:28:58,066
You can check them out in the official documentation in detail

448
00:28:58,168 --> 00:29:02,058
if you want to, but we actually only need to know about RBEC

449
00:29:02,094 --> 00:29:05,794
mode. And since Kubernetes supports multiple modes,

450
00:29:05,922 --> 00:29:09,574
somewhere there should be a configuration of which modes are

451
00:29:09,612 --> 00:29:13,514
enabled, right? So where is that set? That is

452
00:29:13,552 --> 00:29:16,614
actually set in the API server configuration.

453
00:29:16,742 --> 00:29:20,474
So if we check the pod configuration for

454
00:29:20,512 --> 00:29:25,586
API server in manifests

455
00:29:25,718 --> 00:29:29,870
and Kube API server,

456
00:29:30,690 --> 00:29:34,206
among those many parameters that we pass to the

457
00:29:34,228 --> 00:29:37,586
Kube API server application when we started there is a

458
00:29:37,608 --> 00:29:41,314
parameter called authorization mode and

459
00:29:41,352 --> 00:29:45,010
by default when we bootstrap the cluster with

460
00:29:45,080 --> 00:29:49,438
Kubeadm you have node and RBEC authorization

461
00:29:49,534 --> 00:29:52,962
modes enabled. And that means if you're maintaining

462
00:29:53,026 --> 00:29:56,294
a cluster and it doesn't have RBEC enabled by

463
00:29:56,332 --> 00:29:59,270
default, that's where you can edit.

464
00:30:05,890 --> 00:30:09,394
We will look at how client certificates work in

465
00:30:09,432 --> 00:30:12,914
Kubernetes so that you understand the concepts before we

466
00:30:12,952 --> 00:30:16,562
actually create a Kubernetes client certificate for a new

467
00:30:16,616 --> 00:30:20,486
user. Also this will be a refresher of Kubernetes certificates in

468
00:30:20,508 --> 00:30:24,498
general that you already learned in this course. When we execute

469
00:30:24,594 --> 00:30:27,874
Kubeadm init for bootstrapping the cluster,

470
00:30:28,002 --> 00:30:31,682
Kubeadm generates all the needed certificates for

471
00:30:31,756 --> 00:30:35,494
Kubernetes components as we already saw in the auto

472
00:30:35,542 --> 00:30:37,398
generated folder.

473
00:30:37,574 --> 00:30:41,302
EtCPKI,

474
00:30:41,446 --> 00:30:44,962
which you learned stands for public key infrastructure.

475
00:30:45,126 --> 00:30:48,762
We saw server certificates for API server

476
00:30:48,906 --> 00:30:53,274
with private key, API server key and certificate

477
00:30:53,402 --> 00:30:56,954
with public key APiserver CRT

478
00:30:57,082 --> 00:31:00,694
and we also saw server certificates for Etsy

479
00:31:00,842 --> 00:31:03,870
in ECD folder.

480
00:31:03,950 --> 00:31:07,278
Kubeadm init also generated client certificates

481
00:31:07,454 --> 00:31:11,058
for other services that talk to the API server

482
00:31:11,154 --> 00:31:14,818
and we saw the private and public key certificates for clients

483
00:31:14,994 --> 00:31:18,034
in the Kubeconfig files for Kubelet,

484
00:31:18,162 --> 00:31:21,442
scheduler, controller, manager, et cetera.

485
00:31:21,586 --> 00:31:25,862
So now the question is who signed all those certificates

486
00:31:26,006 --> 00:31:28,362
which CA was used here? Well,

487
00:31:28,416 --> 00:31:32,042
Kubeadm actually also generated own

488
00:31:32,096 --> 00:31:35,134
CA for Kubernetes cluster. In fact it

489
00:31:35,172 --> 00:31:39,182
generated a CA for API server and one

490
00:31:39,236 --> 00:31:42,798
for itsty server. But Kubernetes own

491
00:31:42,884 --> 00:31:46,934
generated cas are not globally trusted and recognized

492
00:31:47,002 --> 00:31:50,702
ones, right? So why does it work? Why do all these client

493
00:31:50,766 --> 00:31:54,018
components talking to API server, for example,

494
00:31:54,184 --> 00:31:57,214
acknowledge a server certificate signed

495
00:31:57,262 --> 00:32:00,262
by an auto generated Kubernetes CA?

496
00:32:00,396 --> 00:32:04,534
Because all the clients got a copy of

497
00:32:04,652 --> 00:32:08,082
the Kubernetes CA that signed the API

498
00:32:08,226 --> 00:32:11,666
server certificate in the Kubeconfig files. In addition

499
00:32:11,698 --> 00:32:15,130
to the client's key pair, we also see

500
00:32:15,280 --> 00:32:18,906
CA certificate defined. This way the clients can

501
00:32:18,928 --> 00:32:22,346
verify whether the service certificate was signed by it

502
00:32:22,448 --> 00:32:26,154
and if yes, they know it can be trusted. So just

503
00:32:26,192 --> 00:32:29,626
like your operating system has a list of CAS packaged

504
00:32:29,658 --> 00:32:33,006
in, we just add a new CA to the list of the

505
00:32:33,028 --> 00:32:36,634
client and the client will see the CA as one of the trusted

506
00:32:36,682 --> 00:32:40,366
ones. This means the Kubernetes CAs are actually trusted

507
00:32:40,478 --> 00:32:44,206
within Kubernetes by all components who have a copy

508
00:32:44,238 --> 00:32:48,066
of it. As I

509
00:32:48,088 --> 00:32:52,226
mentioned, Kubernetes allows configuring external credentials

510
00:32:52,338 --> 00:32:56,370
for authentication like tokens, file certificates

511
00:32:56,530 --> 00:33:00,214
or third party services. And I mentioned that these

512
00:33:00,252 --> 00:33:03,866
are all managed externally by you. Kubernetes does

513
00:33:03,888 --> 00:33:07,446
not manage them. In our demo we will actually configure

514
00:33:07,558 --> 00:33:10,470
user authentication using one of these methods,

515
00:33:10,550 --> 00:33:14,134
which is certificates. So we will configure a user

516
00:33:14,182 --> 00:33:17,934
access for one of the developers in the team through a

517
00:33:17,972 --> 00:33:21,966
client certificate. So let's see how this works in Kubernetes for

518
00:33:21,988 --> 00:33:25,822
this it definitely helps to understand how certificates work

519
00:33:25,876 --> 00:33:29,358
in general, regardless of Kubernetes. So if you don't

520
00:33:29,374 --> 00:33:32,766
know anything about certificates, watch the prerequisite

521
00:33:32,798 --> 00:33:36,606
video first and then continue from here. It will be much easier

522
00:33:36,638 --> 00:33:37,380
to understand.

523
00:33:40,090 --> 00:33:44,582
So you as a Kubernetes administrator or the user itself

524
00:33:44,716 --> 00:33:48,642
will generate a client key for the user. Now user

525
00:33:48,706 --> 00:33:52,662
will use this to authenticate with Kubernetes,

526
00:33:52,806 --> 00:33:56,630
so you need this key signed by Kubernetes certificate

527
00:33:56,710 --> 00:34:00,694
authority. For that you will generate a certificate

528
00:34:00,822 --> 00:34:04,310
signing request. Till this point Kubernetes doesn't know anything

529
00:34:04,400 --> 00:34:07,902
about this certificate. So how do we get this

530
00:34:07,956 --> 00:34:11,950
request signed by Kubernetes? Well, Kubernetes has

531
00:34:12,020 --> 00:34:15,626
something called a certificate API which allows

532
00:34:15,658 --> 00:34:19,282
you to send it the csrs or

533
00:34:19,336 --> 00:34:22,754
certificate signing requests and Kubernetes will then sign

534
00:34:22,792 --> 00:34:26,046
it for you using its certificate authority.

535
00:34:26,158 --> 00:34:29,922
Now any user or program can request Kubernetes

536
00:34:29,986 --> 00:34:33,954
to sign a certificate through this programmatic certificate

537
00:34:34,002 --> 00:34:37,874
API. So once requested, it gets in a pending

538
00:34:37,922 --> 00:34:42,214
state so it doesn't automatically get approved for security

539
00:34:42,332 --> 00:34:46,154
reasons and you as a Kubernetes administrator can

540
00:34:46,192 --> 00:34:50,122
make the final decision whether a request can be approved or

541
00:34:50,176 --> 00:34:53,594
denied. Once you approve the request, you will get the

542
00:34:53,632 --> 00:34:57,326
signed certificate from Kubernetes CA, which you can

543
00:34:57,348 --> 00:35:01,482
give to the client to use to authenticate with the cluster.

544
00:35:01,626 --> 00:35:04,942
It may sound a bit complex, but it's actually pretty easy and

545
00:35:04,996 --> 00:35:09,060
straightforward and we're going to see all that in a hands on demo.

546
00:35:12,110 --> 00:35:16,118
A user in Kubernetes for a developer

547
00:35:16,214 --> 00:35:19,722
tom by generating certificates for

548
00:35:19,776 --> 00:35:23,914
Tom and getting it signed by Kubernetes certificate

549
00:35:23,962 --> 00:35:27,130
authority using Kubernetes certificate

550
00:35:27,210 --> 00:35:30,890
API. For that, first we will create a client

551
00:35:30,970 --> 00:35:35,086
key for developer Tom using OpenSSL

552
00:35:35,198 --> 00:35:38,766
command line tool, and then we will ask Kubernetes

553
00:35:38,958 --> 00:35:42,830
certificate API to sign that certificate

554
00:35:42,910 --> 00:35:47,042
signing request for us by creating a Kubernetes

555
00:35:47,106 --> 00:35:50,642
resource called certificate signing request.

556
00:35:50,786 --> 00:35:55,106
Once that's done, we're going to be able to approve the certificate signing request

557
00:35:55,218 --> 00:35:58,586
as a Kubernetes administrator for developer Tom.

558
00:35:58,688 --> 00:36:02,202
And finally we can get the signed certificate for

559
00:36:02,256 --> 00:36:05,366
our user developer Tom from Kubernetes.

560
00:36:05,478 --> 00:36:09,226
And with the resulting files we're going to see how to provide

561
00:36:09,328 --> 00:36:13,422
user Tom with all the certificate files and

562
00:36:13,476 --> 00:36:17,262
all the credentials to be able to access the cluster with

563
00:36:17,316 --> 00:36:21,342
Kubectl command using his own dev Tom

564
00:36:21,476 --> 00:36:24,674
user certificate. So this whole process can

565
00:36:24,712 --> 00:36:28,414
actually be considered similar to creating a user

566
00:36:28,462 --> 00:36:32,638
in Kubernetes, even though Kubernetes doesn't have user objects.

567
00:36:32,734 --> 00:36:36,974
However, once we have the user, it also needs certain permissions

568
00:36:37,102 --> 00:36:40,178
so it is able to authenticate with the cluster,

569
00:36:40,274 --> 00:36:43,730
but it has to be able to do something inside the cluster.

570
00:36:43,810 --> 00:36:47,906
So as a next step, we're going to give this new user dev Tom

571
00:36:48,028 --> 00:36:51,226
certain permissions to create,

572
00:36:51,408 --> 00:36:55,094
delete, update Kubernetes resources like pods,

573
00:36:55,142 --> 00:36:59,242
deployments, services, et cetera, so that he can deploy his

574
00:36:59,296 --> 00:37:03,018
own applications. And finally, we're going to see how to validate

575
00:37:03,114 --> 00:37:06,650
the user permissions by checking what authorization

576
00:37:06,810 --> 00:37:10,462
a user has and what permissions he does not

577
00:37:10,516 --> 00:37:14,254
have. So that's going to be a human user like

578
00:37:14,292 --> 00:37:17,822
a developer tom that will get access to the cluster.

579
00:37:17,966 --> 00:37:21,614
As in the second part, we're going to create a non

580
00:37:21,662 --> 00:37:25,874
human user for a CI CD tool like Jenkins to

581
00:37:25,912 --> 00:37:29,662
be able to access the cluster with its own user.

582
00:37:29,726 --> 00:37:33,042
And for that we're gonna create a service account for Jenkins.

583
00:37:33,186 --> 00:37:37,314
Again, this will create a non human user in Kubernetes

584
00:37:37,442 --> 00:37:41,770
which will need some permissions. So we're going to give the service account certain

585
00:37:41,840 --> 00:37:45,786
permissions in Kubernetes cluster to create,

586
00:37:45,888 --> 00:37:49,946
delete, update Kubernetes resources in only

587
00:37:50,048 --> 00:37:53,534
MyApp namespace. And finally we're going to see

588
00:37:53,652 --> 00:37:57,786
how you would access the cluster from Jenkins

589
00:37:57,898 --> 00:38:02,106
using Kubectl and service account credentials.

590
00:38:02,218 --> 00:38:05,220
We have a lot to do, so let's get right into it.

591
00:38:12,060 --> 00:38:15,940
Great. So first, as I said, we need to generate

592
00:38:16,100 --> 00:38:19,844
users client key and certificate

593
00:38:19,892 --> 00:38:23,944
signing request, which is very easy to do using an OpenSSL

594
00:38:23,992 --> 00:38:27,496
tool that you already learned in one of the previous lectures.

595
00:38:27,608 --> 00:38:31,544
So let's go ahead and do that. OpenSSL command

596
00:38:31,592 --> 00:38:35,360
should already be available on your server so we don't have to install it.

597
00:38:35,430 --> 00:38:39,916
And a subcommand for OpenSSL is gen RSA

598
00:38:40,028 --> 00:38:43,440
because we're generating an RSA key

599
00:38:43,590 --> 00:38:47,570
and the name of the file that will contain the key will be

600
00:38:48,420 --> 00:38:52,228
devtom key and we specify that as

601
00:38:52,314 --> 00:38:56,228
out or output option. And finally we're going

602
00:38:56,234 --> 00:39:00,856
to specify that we want a 2048

603
00:39:01,038 --> 00:39:04,904
bit RSA key. That's it. That will create the

604
00:39:04,942 --> 00:39:09,268
client key for dev Tom user.

605
00:39:09,444 --> 00:39:13,244
And if I ls here, this is the

606
00:39:13,282 --> 00:39:17,100
key and we can also check the contents of this file.

607
00:39:18,400 --> 00:39:21,944
There you go. This is simply an RSA private

608
00:39:21,992 --> 00:39:25,328
key file, so that one's done.

609
00:39:25,414 --> 00:39:29,228
As a next step we're going to create a certificate signing request

610
00:39:29,324 --> 00:39:34,400
for the key that we just generated. Again, open SSL

611
00:39:34,820 --> 00:39:38,324
request because we're creating a new request and the

612
00:39:38,362 --> 00:39:43,524
input for that request is going to be our key because

613
00:39:43,562 --> 00:39:46,916
we want the key to be signed basically.

614
00:39:47,098 --> 00:39:50,836
And again we need to save that request into an output

615
00:39:50,868 --> 00:39:55,210
file and we're going to call that dev Tom

616
00:39:56,540 --> 00:40:01,136
CSR certificate signing request.

617
00:40:01,268 --> 00:40:05,036
And there is one more thing that we are going to do here, which is

618
00:40:05,218 --> 00:40:09,340
adding a subject or setting a subject

619
00:40:09,920 --> 00:40:14,352
inside the certificate that will be then generated where

620
00:40:14,406 --> 00:40:18,224
we set the certificate name to be Tom. And this

621
00:40:18,262 --> 00:40:21,712
basically will indicate that the certificate is

622
00:40:21,846 --> 00:40:25,324
for user Tom and this is going to be the

623
00:40:25,382 --> 00:40:28,928
name which Kubernetes will use when validating

624
00:40:29,024 --> 00:40:32,724
the request using this client key

625
00:40:32,762 --> 00:40:36,020
and certificate. So we're just going to call it Tom

626
00:40:36,170 --> 00:40:39,450
and that's the command. This will actually give us

627
00:40:39,980 --> 00:40:43,748
dev Tom CSR file

628
00:40:43,844 --> 00:40:46,936
right here. Again, let's check how it

629
00:40:46,958 --> 00:40:50,476
looks. And there

630
00:40:50,498 --> 00:40:54,590
you go, you see certificate request and

631
00:40:55,120 --> 00:40:56,670
the contents here.

632
00:41:00,640 --> 00:41:04,496
So we have those two files here. Now as a next step we

633
00:41:04,518 --> 00:41:07,916
need to send this certificate signing request

634
00:41:08,028 --> 00:41:11,376
to Kubernetes itself so that Kubernetes can sign it

635
00:41:11,398 --> 00:41:15,336
for us using the certificate authority of Kubernetes.

636
00:41:15,468 --> 00:41:18,676
And we do that again by creating components in

637
00:41:18,698 --> 00:41:22,324
Kubernetes in a Kubernetes native way, as you already know,

638
00:41:22,442 --> 00:41:25,876
using configuration files. So I'm going to go

639
00:41:25,898 --> 00:41:31,160
to Kubernetes documentation and search for certificate

640
00:41:31,580 --> 00:41:33,640
signing request.

641
00:41:34,700 --> 00:41:38,724
And here we have an example of how a certificate signing

642
00:41:38,772 --> 00:41:42,364
request resource in Kubernetes will look like.

643
00:41:42,482 --> 00:41:45,944
So I'm simply going to copy this example. So I'll take the yaml

644
00:41:45,992 --> 00:41:50,344
part from here and we're going to create file

645
00:41:50,392 --> 00:41:55,172
called Dev Tom CSR

646
00:41:55,336 --> 00:41:59,420
Yaml and let's paste the contents.

647
00:41:59,500 --> 00:42:02,396
So again certificate signing request,

648
00:42:02,508 --> 00:42:06,476
that's a Kubernetes object coming from this API group

649
00:42:06,598 --> 00:42:09,796
with this version and a couple of attributes here in the

650
00:42:09,818 --> 00:42:13,780
specification. First let's change the name. Let's call it

651
00:42:13,930 --> 00:42:17,312
Dev Tom. And the main part in the specification

652
00:42:17,456 --> 00:42:20,728
is the request itself. So what is this

653
00:42:20,814 --> 00:42:24,996
value? You can also check that in documentation. Actually the request

654
00:42:25,108 --> 00:42:28,760
value that we set here is base 64

655
00:42:28,830 --> 00:42:32,312
encoded value of the CSR

656
00:42:32,376 --> 00:42:36,396
file that we generated. And you also see an example of

657
00:42:36,578 --> 00:42:39,960
how to get that value from the CSR file.

658
00:42:40,040 --> 00:42:44,130
So let's copy that. I'm going to save this changes

659
00:42:44,500 --> 00:42:48,688
and we need the base 64 encoded value

660
00:42:48,774 --> 00:42:52,288
of the CSR file contents. So the command that

661
00:42:52,294 --> 00:42:55,990
I copied, of course we have to adjust the name

662
00:42:57,400 --> 00:43:01,204
like this. So what we are doing is we are printing out

663
00:43:01,242 --> 00:43:05,872
the contents of Dev Tom CSR

664
00:43:05,936 --> 00:43:09,284
file. Then we are base 64 encoding

665
00:43:09,332 --> 00:43:12,808
those contents by piping it to base 64

666
00:43:12,894 --> 00:43:16,824
program. And then we're removing all the new

667
00:43:16,862 --> 00:43:19,592
lines because we want the contents in one line.

668
00:43:19,646 --> 00:43:23,352
Basically we don't need new lines, so we're trimming

669
00:43:23,416 --> 00:43:26,360
all the new lines. So let's execute.

670
00:43:26,520 --> 00:43:30,220
So that's the value, the basics before

671
00:43:30,290 --> 00:43:33,276
encoded value of this file.

672
00:43:33,388 --> 00:43:37,680
So back to our Kubernetes configuration file,

673
00:43:38,820 --> 00:43:42,176
Dev Tomcsr Yaml. And what

674
00:43:42,198 --> 00:43:45,244
I'm going to do is I'm going to push the existing value to a new

675
00:43:45,302 --> 00:43:49,284
line and then I'm going to just delete it by clicking d

676
00:43:49,402 --> 00:43:53,156
twice and paste in

677
00:43:53,178 --> 00:43:56,964
the new value. And there you go. And note that this is one

678
00:43:57,162 --> 00:44:00,436
string basically without any new lines

679
00:44:00,468 --> 00:44:04,090
here, which is exactly what we need. The signer name will stay the same,

680
00:44:04,780 --> 00:44:09,204
usages will stay the same. This is a client certificate

681
00:44:09,332 --> 00:44:13,036
and we can actually extend the expiration date to

682
00:44:13,138 --> 00:44:17,230
longer than one day. So this would be around 100 days.

683
00:44:20,000 --> 00:44:23,388
So basically we set an expiration date on the certificate

684
00:44:23,484 --> 00:44:27,148
and we renew it regularly before it gets expired.

685
00:44:27,324 --> 00:44:31,024
And I'm going to save this and we have our

686
00:44:31,222 --> 00:44:35,520
certificate signing request configuration for kubernetes.

687
00:44:35,960 --> 00:44:39,924
And just like any other Kubernetes configuration file we

688
00:44:39,962 --> 00:44:43,540
need to apply it using

689
00:44:43,610 --> 00:44:48,644
Qctl apply command. So Dev Tom CSR

690
00:44:48,692 --> 00:44:52,804
Yaml and when we apply the file we should get this error

691
00:44:52,852 --> 00:44:56,840
that says that expiration seconds attribute or

692
00:44:56,910 --> 00:45:00,476
field is unknown. And the reason for

693
00:45:00,498 --> 00:45:04,104
that is because that field was actually added in the latest

694
00:45:04,232 --> 00:45:07,580
Kubernetes version 1.22.

695
00:45:07,730 --> 00:45:10,936
And we have installed Kubernetes

696
00:45:11,048 --> 00:45:14,944
version 1.21 so

697
00:45:14,982 --> 00:45:18,784
that's why it's not supported. What we can do is

698
00:45:18,982 --> 00:45:23,004
basically just comment out or simply

699
00:45:23,052 --> 00:45:26,276
remove the field and maybe use it when we upgrade the

700
00:45:26,298 --> 00:45:29,908
cluster version. So I'm going to save the changes

701
00:45:30,074 --> 00:45:33,872
and let's try to apply again. And there you go. So by creating

702
00:45:33,936 --> 00:45:36,976
this CSR or certificate signing

703
00:45:37,008 --> 00:45:40,984
request resource in Kubernetes, we basically sent the

704
00:45:41,022 --> 00:45:44,372
Kubernetes certificate API a request

705
00:45:44,516 --> 00:45:48,404
to sign our dev tom users

706
00:45:48,452 --> 00:45:51,868
certificate. So let's see the state

707
00:45:52,034 --> 00:45:56,044
Kubectl get. CSR will

708
00:45:56,082 --> 00:45:59,756
actually list us all the signing requests that

709
00:45:59,778 --> 00:46:02,504
are in the cluster and their conditions,

710
00:46:02,552 --> 00:46:06,384
which this one is in a pending state. And we

711
00:46:06,422 --> 00:46:10,464
as Kubernetes administrators also have to have

712
00:46:10,502 --> 00:46:13,936
the ability to approve this. So that's the name

713
00:46:14,038 --> 00:46:17,760
of the requester which is Kubernetes admin user.

714
00:46:17,920 --> 00:46:21,316
That's the user we are connecting to the

715
00:46:21,338 --> 00:46:24,436
cluster right now and executing the Kubectl commands. And the

716
00:46:24,458 --> 00:46:30,356
user is basically defined in Kubeconfig

717
00:46:30,388 --> 00:46:33,992
file that our Kubectl command is using.

718
00:46:34,126 --> 00:46:37,400
So I'm going to do grep Kubernetes

719
00:46:38,700 --> 00:46:43,484
admin and let's print out two

720
00:46:43,522 --> 00:46:47,736
lines or so. And there you go. In the Kubeconfig

721
00:46:47,768 --> 00:46:51,224
file we have the user which is Kubernetes admin

722
00:46:51,352 --> 00:46:55,280
and that's the user we are executing those Kubectl commands with.

723
00:46:55,350 --> 00:46:59,440
So that's the requester and we as an admin also

724
00:46:59,510 --> 00:47:04,112
have the permission to approve any

725
00:47:04,246 --> 00:47:09,636
certificate signing requests and

726
00:47:09,658 --> 00:47:11,110
that's what we're going to do.

727
00:47:13,160 --> 00:47:17,596
We're going to approve this request and for that there is a subcommand

728
00:47:17,728 --> 00:47:20,120
called Kubectl certificate.

729
00:47:21,260 --> 00:47:24,884
We can also see the help information on that. And this command

730
00:47:24,932 --> 00:47:28,276
is used to modify any certificate resources

731
00:47:28,308 --> 00:47:32,472
in the cluster. And we have proof or deny commands

732
00:47:32,616 --> 00:47:36,200
for approving or denying csrs.

733
00:47:36,280 --> 00:47:39,884
So Kubectl certificate approve and we

734
00:47:39,922 --> 00:47:43,810
need the name of the CSR which is Dev Tom

735
00:47:44,820 --> 00:47:48,592
approve. And now let's check again. We should have

736
00:47:48,726 --> 00:47:52,672
CSR in an approved and issued state.

737
00:47:52,806 --> 00:47:56,340
And this means we actually just got

738
00:47:56,490 --> 00:48:00,144
our CSR signed by Kubernetes

739
00:48:00,192 --> 00:48:03,924
CA and that signed certificate is what

740
00:48:03,962 --> 00:48:07,664
we need for dev Tom user to

741
00:48:07,802 --> 00:48:11,800
connect to the cluster. So we're going to extract that information using

742
00:48:11,870 --> 00:48:15,880
Kubectl, get CSR dev

743
00:48:15,950 --> 00:48:20,084
Tom and then printing it out in a yaml format.

744
00:48:20,212 --> 00:48:23,596
So we're getting the details of this CSR and

745
00:48:23,698 --> 00:48:27,212
as you see here we have a bunch of attributes like

746
00:48:27,266 --> 00:48:31,096
the request that we set signer name et cetera,

747
00:48:31,208 --> 00:48:35,548
and a new field in the status called certificate.

748
00:48:35,644 --> 00:48:38,924
So as you know, status section is automatically

749
00:48:38,972 --> 00:48:42,796
generated by Kubernetes. And this section

750
00:48:42,828 --> 00:48:46,336
was basically automatically edited with all

751
00:48:46,358 --> 00:48:50,064
these values. And one of them is the signed certificate

752
00:48:50,192 --> 00:48:54,352
for our user which is again base 64 encoded.

753
00:48:54,416 --> 00:48:58,188
So we would have to decode it to see the actual certificate.

754
00:48:58,304 --> 00:49:01,976
So I'm going to copy that. And since we

755
00:49:01,998 --> 00:49:05,316
have devtom key which is the private

756
00:49:05,348 --> 00:49:09,012
key, we can also create devtom CRT

757
00:49:09,156 --> 00:49:13,080
certificate which is going to be the public key of that pair.

758
00:49:13,240 --> 00:49:16,716
And that's very easy to do.

759
00:49:16,818 --> 00:49:20,876
We're going to basically echo the

760
00:49:20,898 --> 00:49:24,556
base 64 encoded contents of the certificate.

761
00:49:24,668 --> 00:49:29,504
Then we're going to decode it like

762
00:49:29,542 --> 00:49:33,904
this. Let's see that first of all. And as you see we get

763
00:49:34,102 --> 00:49:38,390
an actual certificate and

764
00:49:38,920 --> 00:49:42,324
we could actually save this into a

765
00:49:42,362 --> 00:49:46,260
file called Dev Tom CRT.

766
00:49:46,760 --> 00:49:50,632
Let's clear this Ls and that's our

767
00:49:50,686 --> 00:49:54,376
file. Let's check the contents. And there

768
00:49:54,398 --> 00:49:58,424
you go. So now we have a key pair for our user which

769
00:49:58,462 --> 00:50:01,964
is private key and public key with

770
00:50:02,002 --> 00:50:06,024
the certificate which is signed by Kubernetes certificate

771
00:50:06,072 --> 00:50:06,940
authority.

772
00:50:13,630 --> 00:50:17,142
Now we have all the files that we need for devtom

773
00:50:17,206 --> 00:50:21,354
user, but how do we actually connect to the cluster

774
00:50:21,402 --> 00:50:24,634
now with this user's client

775
00:50:24,682 --> 00:50:28,174
certificate? So as a next step, let's see how that

776
00:50:28,212 --> 00:50:32,282
works. So basically when we give all these files to Tom,

777
00:50:32,436 --> 00:50:36,530
the developer, how does he connect to the cluster using

778
00:50:36,600 --> 00:50:40,434
his client certificate? So that's what we're going to see as a next step.

779
00:50:40,552 --> 00:50:43,626
Right now when we execute Kubectl commands,

780
00:50:43,758 --> 00:50:47,574
Kubectl actually uses the admin certificate because

781
00:50:47,612 --> 00:50:51,298
that's what we have configured in the default

782
00:50:51,474 --> 00:50:54,098
cube config file.

783
00:50:54,194 --> 00:50:57,734
So we need to actually execute the Kubectl command

784
00:50:57,862 --> 00:51:01,206
using the dev tom user.

785
00:51:01,318 --> 00:51:04,842
So one way of doing that is to pass all the options

786
00:51:04,976 --> 00:51:08,874
to the Kubectl command to override this default admin

787
00:51:09,002 --> 00:51:12,254
configuration and to see what options we have

788
00:51:12,292 --> 00:51:15,630
available. We can actually execute Kubectl options

789
00:51:15,780 --> 00:51:20,174
command which will show us all the global configuration options that

790
00:51:20,212 --> 00:51:23,698
apply to any Kubectl command. And there are

791
00:51:23,704 --> 00:51:27,806
a bunch of them here, but the ones that we are interested in are client

792
00:51:27,838 --> 00:51:31,566
certificate, client key, certificate authority

793
00:51:31,758 --> 00:51:35,634
and server which is the address and port of Kubernetes

794
00:51:35,682 --> 00:51:38,834
API server. And with these we're basically overriding

795
00:51:38,962 --> 00:51:43,186
the default values coming from cubeconfig

796
00:51:43,218 --> 00:51:46,906
file. So let's try to configure that. First of

797
00:51:46,928 --> 00:51:50,650
all, where do we find the API server address?

798
00:51:50,800 --> 00:51:54,154
We can look it up in the Kubeconfig file or we can

799
00:51:54,192 --> 00:51:57,798
just do cluster info and

800
00:51:57,984 --> 00:52:01,786
that's the address of API server.

801
00:52:01,898 --> 00:52:05,950
So Kubectl server

802
00:52:07,250 --> 00:52:11,554
the address, let's go to a new line and

803
00:52:11,592 --> 00:52:15,490
specify certificate authority

804
00:52:17,270 --> 00:52:24,922
which is located in EtcPKI

805
00:52:25,086 --> 00:52:28,326
folder. That's where

806
00:52:28,348 --> 00:52:32,166
all the Kubernetes certificates are located on the master node as you

807
00:52:32,188 --> 00:52:35,690
already learned. So that's the certificate authority. Then we need

808
00:52:35,760 --> 00:52:40,282
client certificate which

809
00:52:40,336 --> 00:52:44,890
is Dev Tom certificate,

810
00:52:45,950 --> 00:52:49,566
that's the file that we generated, that's signed by

811
00:52:49,588 --> 00:52:52,350
the certificate authority of kubernetes.

812
00:52:53,330 --> 00:52:56,942
Then we have client key which is again

813
00:52:56,996 --> 00:53:00,190
what we generated at the beginning

814
00:53:00,630 --> 00:53:04,770
and that's it. So we're telling Kubectl go to this server,

815
00:53:05,910 --> 00:53:09,454
use this certificate authority to authenticate

816
00:53:09,502 --> 00:53:13,750
the server, use this client certificate and key

817
00:53:13,900 --> 00:53:17,506
to authenticate yourself with the API

818
00:53:17,538 --> 00:53:21,154
server. And finally we need the actual Kubectl

819
00:53:21,202 --> 00:53:24,806
command like get pod and let's execute. And when

820
00:53:24,828 --> 00:53:28,362
we execute this we're going to have a couple of issues here. The first one

821
00:53:28,416 --> 00:53:31,254
is that when we execute this command,

822
00:53:31,302 --> 00:53:35,020
Kubectl takes all those configuration options,

823
00:53:35,470 --> 00:53:38,602
plus it will also check the configuration from

824
00:53:38,656 --> 00:53:42,202
the default cube config file.

825
00:53:42,346 --> 00:53:45,626
And it says that in this default cube config

826
00:53:45,658 --> 00:53:48,922
file, client cert data and client

827
00:53:49,066 --> 00:53:52,994
key data are defined. And this one

828
00:53:53,032 --> 00:53:56,238
has the precedence over client certificate

829
00:53:56,334 --> 00:54:00,066
and client certificate data. And client key data

830
00:54:00,248 --> 00:54:03,634
options have precedence or they override

831
00:54:03,682 --> 00:54:07,622
basically client certificate and client key options. So again

832
00:54:07,676 --> 00:54:12,790
to check that kubeconfig,

833
00:54:13,690 --> 00:54:16,822
we see that in the default kubeconfig file,

834
00:54:16,966 --> 00:54:20,966
the client certificate and client key values are defined

835
00:54:21,078 --> 00:54:25,046
directly in the kubeconfig file. So we have the file contents

836
00:54:25,078 --> 00:54:29,274
inside instead of link to the file. So this attribute

837
00:54:29,322 --> 00:54:33,070
name, client certificate data takes precedence over

838
00:54:33,220 --> 00:54:37,022
attribute called client certificate which references the

839
00:54:37,076 --> 00:54:40,626
file. So to test our

840
00:54:40,648 --> 00:54:44,878
command let's actually move this default file

841
00:54:45,054 --> 00:54:51,586
temporarily from

842
00:54:51,768 --> 00:54:56,274
cube folder to current folder so

843
00:54:56,312 --> 00:54:59,990
it's not in the cube cube folder anymore.

844
00:55:00,410 --> 00:55:04,390
And let's execute our Kubectl command again with

845
00:55:04,540 --> 00:55:08,166
dev Tom users client certificate

846
00:55:08,198 --> 00:55:11,850
and key and execute. And there you go. This actually

847
00:55:11,920 --> 00:55:15,846
worked because we were able to connect to the cluster

848
00:55:15,958 --> 00:55:19,786
and request to list the pods.

849
00:55:19,898 --> 00:55:23,950
The error that you see here is because we haven't given our dev

850
00:55:24,020 --> 00:55:27,566
Tom user any permissions for the cluster yet.

851
00:55:27,668 --> 00:55:30,410
So what we get is basically forbidden.

852
00:55:30,490 --> 00:55:34,574
So we have been authenticated with kubernetes, but Devtom

853
00:55:34,622 --> 00:55:37,858
user is not authorized to do anything and we're going to

854
00:55:37,864 --> 00:55:41,618
authorize him later in this lecture. So that's basically

855
00:55:41,784 --> 00:55:45,366
one way of specifying credentials of a

856
00:55:45,388 --> 00:55:48,870
specific user with Kubectl commands.

857
00:55:51,610 --> 00:55:55,714
However, passing those values to every Kubectl

858
00:55:55,762 --> 00:55:58,854
command as you can imagine will be very annoying.

859
00:55:58,982 --> 00:56:02,474
So how can we avoid this and instead

860
00:56:02,592 --> 00:56:06,474
go back to using our kubeconfig file? Well, just like we use

861
00:56:06,592 --> 00:56:09,866
the admin user's kubeconfig file,

862
00:56:09,978 --> 00:56:13,498
we can actually create our own kubeconfig file

863
00:56:13,594 --> 00:56:16,942
for devtom user. So let's do that as a next

864
00:56:16,996 --> 00:56:20,662
step. And for that I'm going to take the admin

865
00:56:20,746 --> 00:56:24,622
user's kubeconfig file which we just copied

866
00:56:24,766 --> 00:56:29,426
and we have it here and I'm going to create

867
00:56:29,528 --> 00:56:32,974
a duplicate of it and call it devtom

868
00:56:33,102 --> 00:56:36,194
conf. And now let's

869
00:56:36,242 --> 00:56:40,134
actually change all the values from admin to

870
00:56:40,252 --> 00:56:44,098
devtom user. So first of all we are reusing

871
00:56:44,194 --> 00:56:48,102
what kubernetes already generated for us or for the admin

872
00:56:48,166 --> 00:56:51,834
user. We have the certificate authority data already inside.

873
00:56:51,952 --> 00:56:55,978
We have the server API, server address here, so everything's going

874
00:56:55,984 --> 00:56:59,678
to stay the same. But there are a couple of things that we need to

875
00:56:59,844 --> 00:57:03,774
adjust. One of them is the name of the

876
00:57:03,812 --> 00:57:07,802
user. So we are not using Kubernetes admin anymore.

877
00:57:07,866 --> 00:57:11,610
We have dev Tom user in the user section.

878
00:57:11,770 --> 00:57:15,294
And do not forget to also change the

879
00:57:15,332 --> 00:57:19,378
user in the contexts because that's the reference to

880
00:57:19,544 --> 00:57:23,266
the name of the user and change it here as

881
00:57:23,288 --> 00:57:27,090
well like this.

882
00:57:27,240 --> 00:57:30,850
So we replaced the user everywhere. Now it's time to replace

883
00:57:30,930 --> 00:57:34,598
the client certificate data for Tom.

884
00:57:34,764 --> 00:57:38,102
These are client certificate and key for admin.

885
00:57:38,246 --> 00:57:42,886
Now we have two options here. We can either reference

886
00:57:42,998 --> 00:57:46,314
the client certificate and client key files just

887
00:57:46,352 --> 00:57:50,158
like we did in our Kubectl command, or we can

888
00:57:50,324 --> 00:57:53,690
base 64 encode the contents of the file

889
00:57:53,770 --> 00:57:57,262
and then paste those contents right here

890
00:57:57,316 --> 00:58:00,550
as value in order to reference the files.

891
00:58:00,650 --> 00:58:04,654
If we don't want to have the contents of certificate and key files

892
00:58:04,702 --> 00:58:09,154
here, we can use client certificate and

893
00:58:09,272 --> 00:58:11,970
client key attributes.

894
00:58:15,610 --> 00:58:19,320
And again I'm going to delete the line here

895
00:58:20,250 --> 00:58:23,958
and here

896
00:58:24,044 --> 00:58:28,460
as well. And this will be referencing dev

897
00:58:29,150 --> 00:58:33,210
Tom cert crt

898
00:58:33,870 --> 00:58:37,766
dev tom key. And this makes our kubeconfig

899
00:58:37,798 --> 00:58:41,566
file a little cleaner and it's a little less work for

900
00:58:41,588 --> 00:58:45,834
us because we're simply referencing the files. Now know that the location

901
00:58:45,882 --> 00:58:49,898
of the file has to be obviously correct and we're going to specify

902
00:58:49,994 --> 00:58:53,874
absolute path for both files so

903
00:58:53,912 --> 00:58:57,230
that it works no matter where you put your kubeconfig file.

904
00:58:57,310 --> 00:59:01,694
So let's save it. And now we can execute the Kubectl

905
00:59:01,742 --> 00:59:06,742
command with the kubeconfig file of

906
00:59:06,876 --> 00:59:10,918
Tom's user. And let's execute again. We have

907
00:59:11,004 --> 00:59:14,802
connected to the server, we have authenticated with kubernetes,

908
00:59:14,946 --> 00:59:18,774
but we're not allowed to list any pods or user.

909
00:59:18,822 --> 00:59:22,278
Tom is not allowed to list anything in the cluster.

910
00:59:22,454 --> 00:59:25,882
So now as a kube admin what you basically do

911
00:59:25,936 --> 00:59:29,590
is you take the kubeconfig file that we just generated

912
00:59:29,670 --> 00:59:33,510
for Dev Tom user. You take the certificate

913
00:59:33,590 --> 00:59:37,418
file and the key file and you basically give all those

914
00:59:37,504 --> 00:59:41,234
three files to Tom and he can use

915
00:59:41,272 --> 00:59:45,202
that to execute Kubectl commands against the cluster. So on

916
00:59:45,256 --> 00:59:48,818
his own laptop, Tom can basically take this

917
00:59:48,904 --> 00:59:52,130
kubeconfig file and put it in his own home

918
00:59:52,200 --> 00:59:56,542
directory, kube config

919
00:59:56,686 --> 00:59:57,070
location.

