1
00:00:00,170 --> 00:00:03,722
Happens, Kubeadm generates a configuration for Kubelet

2
00:00:03,866 --> 00:00:08,046
and puts it in this location as well as

3
00:00:08,228 --> 00:00:11,466
generates environment file and then starts

4
00:00:11,498 --> 00:00:15,534
the Kubelet service. So that means if we do

5
00:00:15,732 --> 00:00:20,682
service Kubelet status

6
00:00:20,746 --> 00:00:24,622
again. Now you see that Kubelet is

7
00:00:24,676 --> 00:00:28,006
in an active running state and here you

8
00:00:28,028 --> 00:00:31,542
see the logs of Kubelet starting up. So after

9
00:00:31,596 --> 00:00:35,238
certificates get generated, the Kubeconfig files are ready to

10
00:00:35,404 --> 00:00:39,418
make it possible for applications to talk to API server as well

11
00:00:39,424 --> 00:00:43,274
as Kubelet starts. Kubeadm will create the

12
00:00:43,312 --> 00:00:47,478
manifest files so that static pods can be created

13
00:00:47,574 --> 00:00:51,866
which will be scheduled by Kubelet and they will use Kubeconfig

14
00:00:51,898 --> 00:00:55,854
files with the certificate information to talk

15
00:00:55,892 --> 00:00:58,778
to each other or talk to the API server.

16
00:00:58,874 --> 00:01:03,186
So that is the next step. And those manifest files get

17
00:01:03,288 --> 00:01:06,574
generated and put into this manifests folder.

18
00:01:06,702 --> 00:01:10,382
And here you see the manifests of those components.

19
00:01:10,526 --> 00:01:14,334
Now we will learn the syntax and how to write Kubernetes manifest

20
00:01:14,382 --> 00:01:17,906
files in detail in the later section of this course.

21
00:01:18,008 --> 00:01:21,714
So it's totally fine if you don't understand the contents and the syntax

22
00:01:21,762 --> 00:01:25,254
of these manifest files right now, but we're going to take a

23
00:01:25,292 --> 00:01:29,194
quick look at them to see some interesting information. And if

24
00:01:29,232 --> 00:01:32,038
we check one of those manifest files,

25
00:01:32,134 --> 00:01:35,306
for example for API server, I'll send

26
00:01:35,328 --> 00:01:40,494
it to less and

27
00:01:40,532 --> 00:01:44,234
we need pseudo because again this folder is accessible

28
00:01:44,282 --> 00:01:48,014
for root user only. And there you go, you see

29
00:01:48,052 --> 00:01:52,190
that it's actually just a regular Kubernetes

30
00:01:52,550 --> 00:01:56,334
pod definition. We have kind pod here with the metadata

31
00:01:56,382 --> 00:01:59,570
and labels and specification.

32
00:02:02,450 --> 00:02:05,834
We're Kube API server. This is the image for Kube

33
00:02:05,882 --> 00:02:11,054
API server with the version. So this application starts

34
00:02:11,182 --> 00:02:14,622
with all of these configuration parameters.

35
00:02:14,766 --> 00:02:18,934
And this is a very interesting and important thing

36
00:02:18,972 --> 00:02:22,246
for Kubernetes administrators because this is a

37
00:02:22,268 --> 00:02:25,894
way to know and check basically

38
00:02:26,092 --> 00:02:30,022
how your API server is configured. So what

39
00:02:30,156 --> 00:02:33,962
values are set for different parameters and also a place

40
00:02:34,016 --> 00:02:37,434
where you can override or adjust some of these

41
00:02:37,472 --> 00:02:41,226
values. Some of the parameters here are for

42
00:02:41,328 --> 00:02:45,054
pointing to the certificate locations, right?

43
00:02:45,172 --> 00:02:49,370
So this is the API server's server certificates

44
00:02:49,530 --> 00:02:53,562
and these are passed in to the Kube API server

45
00:02:53,626 --> 00:02:57,134
application using these parameters.

46
00:02:57,262 --> 00:03:01,326
We also have pointer to the client certificates

47
00:03:01,438 --> 00:03:04,690
for connecting to eTCD right here.

48
00:03:04,840 --> 00:03:08,526
Right. And this is the location where we actually sew those certificates

49
00:03:08,638 --> 00:03:12,450
as well as an endpoint of Etsyd server.

50
00:03:12,530 --> 00:03:16,182
This is the port where ETCD server will run and be

51
00:03:16,236 --> 00:03:20,342
accessible. We also have Kubelet certificate locations and

52
00:03:20,396 --> 00:03:23,946
key file location and so on. So again,

53
00:03:24,048 --> 00:03:27,514
for troubleshooting or changing different parameters for how

54
00:03:27,552 --> 00:03:31,226
your API server runs. This is basically how you

55
00:03:31,248 --> 00:03:34,862
can override them and change them. And what will happen is

56
00:03:34,996 --> 00:03:38,634
if you change something or adjust something in this configuration

57
00:03:38,762 --> 00:03:42,702
and then save that file, Kubelet will actually see

58
00:03:42,756 --> 00:03:46,646
that a change has been made inside this manifests

59
00:03:46,778 --> 00:03:50,626
folder because it watches for any changes inside that and

60
00:03:50,648 --> 00:03:53,842
it will restart the pod with those changes.

61
00:03:53,976 --> 00:03:57,522
Let's also check ETCD YamL, which is

62
00:03:57,576 --> 00:04:00,994
again same thing, it's a pod kind and we are starting

63
00:04:01,112 --> 00:04:05,010
an Etsyd application with bunch of parameters.

64
00:04:05,170 --> 00:04:08,454
Again, the CA certificate, the service certificate of

65
00:04:08,492 --> 00:04:12,562
Etsyd, as well as configuration for peers.

66
00:04:12,706 --> 00:04:16,822
So basically if we had more than one eTCD in the cluster

67
00:04:16,886 --> 00:04:20,810
for high availability on other master nodes, for example,

68
00:04:20,960 --> 00:04:25,338
then we would have an ECD cluster and this will be configuration

69
00:04:25,434 --> 00:04:28,714
for those ECD pods,

70
00:04:28,762 --> 00:04:31,902
basically talking to each other and connecting to each other as

71
00:04:31,956 --> 00:04:36,074
peers. And we also have a location where the

72
00:04:36,132 --> 00:04:39,982
data is actually saved, which is varleep

73
00:04:40,126 --> 00:04:43,874
etc inside the pod. And the same way you can check

74
00:04:43,912 --> 00:04:47,694
the scheduler and controller manager manifest

75
00:04:47,742 --> 00:04:51,638
files after the manifest creation. We also have some other

76
00:04:51,724 --> 00:04:55,414
configuration setups here. And at the end of

77
00:04:55,452 --> 00:04:58,802
all this configuration you also see a phase

78
00:04:58,866 --> 00:05:02,630
called add ons. So basically two additional

79
00:05:02,710 --> 00:05:06,198
applications get deployed inside the cluster,

80
00:05:06,294 --> 00:05:09,590
not as static pods, but rather as add ons.

81
00:05:09,670 --> 00:05:13,302
So basically these are added as regular

82
00:05:13,366 --> 00:05:16,766
pods because the control plane pods are already running,

83
00:05:16,868 --> 00:05:21,018
so they can actually already take over scheduling

84
00:05:21,114 --> 00:05:24,366
the pods. One of them is Kubeproxy, which as

85
00:05:24,388 --> 00:05:27,834
we know, again we need on each node. So Kubeproxy

86
00:05:27,882 --> 00:05:31,614
needs to be on master node as well. And another one is core DNS,

87
00:05:31,742 --> 00:05:35,362
which is an application that we're going to go into more

88
00:05:35,416 --> 00:05:38,654
detail in one of the later lectures.

89
00:05:38,782 --> 00:05:42,514
But as you see here, those two get also automatically

90
00:05:42,562 --> 00:05:47,346
deployed in the cluster when we initiate it with Kubeadm.

91
00:05:47,458 --> 00:05:51,266
So we saw what got created, what got generated. We saw

92
00:05:51,388 --> 00:05:54,982
the Kubernetes folder

93
00:05:55,046 --> 00:05:58,614
where the configuration files as well as manifest files and certificates

94
00:05:58,662 --> 00:06:02,234
are located. And this is basically where you can check how

95
00:06:02,272 --> 00:06:05,902
your control plane components are configured. And we also saw that

96
00:06:05,956 --> 00:06:09,690
Kubelet has its own separate configuration location,

97
00:06:09,770 --> 00:06:13,754
which is Kubelet.

98
00:06:13,882 --> 00:06:15,920
We can also check that as well.

99
00:06:18,230 --> 00:06:21,442
And again, it's a protected directory, so we need

100
00:06:21,496 --> 00:06:25,090
pseudo. And this means that if you want to

101
00:06:25,160 --> 00:06:29,842
check the configuration of Kubelet itself and

102
00:06:29,976 --> 00:06:33,122
check Kubelet's certificates, et cetera,

103
00:06:33,266 --> 00:06:36,326
this is basically where everything is

104
00:06:36,428 --> 00:06:39,298
configured in a different directory,

105
00:06:39,394 --> 00:06:43,766
right? Again, because Kubelet runs as a process directly,

106
00:06:43,878 --> 00:06:47,766
not as a pod. So in the PKI folder

107
00:06:47,798 --> 00:06:52,438
we have the server certificates of Kubelet because API server

108
00:06:52,614 --> 00:06:56,014
will connect to it as a client as well as a

109
00:06:56,052 --> 00:07:00,030
client certificate for connecting to the API server

110
00:07:07,190 --> 00:07:10,878
and the main configuration which again gets generated

111
00:07:10,974 --> 00:07:15,134
by the Kubeadm which is config Yaml

112
00:07:15,182 --> 00:07:18,350
here and this is what's configured inside.

113
00:07:18,520 --> 00:07:21,826
And one of the things I already mentioned is the static

114
00:07:21,938 --> 00:07:25,298
pod path which by default is configured

115
00:07:25,394 --> 00:07:29,186
for Kubelet at this location. So that's

116
00:07:29,218 --> 00:07:33,542
basically the behind the scenes of cluster

117
00:07:33,606 --> 00:07:38,006
initiation as well as how the master components

118
00:07:38,118 --> 00:07:41,722
start and how they are configured and where you can

119
00:07:41,776 --> 00:07:45,722
find and change all this configuration as a Kubernetes

120
00:07:45,786 --> 00:07:49,354
administrator. Now we saw all these folders

121
00:07:49,402 --> 00:07:52,634
that were created and all the configuration files,

122
00:07:52,762 --> 00:07:57,066
but how do we actually see those pods

123
00:07:57,098 --> 00:08:00,734
that are running in the cluster or how do we check the cluster

124
00:08:00,782 --> 00:08:04,226
status and see what's running inside? How do we

125
00:08:04,248 --> 00:08:07,826
connect to the cluster to get all this information? Because right now we

126
00:08:07,848 --> 00:08:11,254
don't see anything about the cluster itself. And that's going to be our

127
00:08:11,292 --> 00:08:13,190
topic for the next lecture.

128
00:08:16,200 --> 00:08:19,824
How do we access the cluster once it's configured?

129
00:08:19,952 --> 00:08:23,956
As we already saw, accessing the Kubernetes cluster,

130
00:08:24,068 --> 00:08:27,780
which basically means accessing the Kube API server

131
00:08:27,860 --> 00:08:32,020
which is the entry point to the cluster, we need certificates

132
00:08:32,180 --> 00:08:36,264
and we saw that Kubeadm generated client

133
00:08:36,312 --> 00:08:40,296
certificate that we can use to administer the cluster.

134
00:08:40,408 --> 00:08:44,012
And we also saw that a Kubeconfig file was created that

135
00:08:44,066 --> 00:08:47,784
has the information about the address of the API server.

136
00:08:47,832 --> 00:08:51,712
So basically where we're connecting to the cluster as well as

137
00:08:51,846 --> 00:08:55,968
that admin user's certificate and

138
00:08:56,054 --> 00:08:59,788
private key. So that's the file we're going to use to

139
00:08:59,894 --> 00:09:03,732
connect to the cluster. And you also learned that

140
00:09:03,866 --> 00:09:08,304
Kubernetes has a client command line tool called Kubectl

141
00:09:08,432 --> 00:09:12,812
which allows us to issue commands to the Kubernetes

142
00:09:12,896 --> 00:09:16,472
cluster. So Kubectl tool will give us

143
00:09:16,526 --> 00:09:20,344
commands to connect to the cluster and the kubeconfig for the

144
00:09:20,382 --> 00:09:24,660
admin user will allow us to then authenticate

145
00:09:24,740 --> 00:09:28,012
with the cluster. So let's see how that works.

146
00:09:28,146 --> 00:09:31,772
So the Kubectl command to get information about

147
00:09:31,826 --> 00:09:35,596
cluster nodes, for example, is Kubectl get node. Now if

148
00:09:35,618 --> 00:09:39,200
I execute this, you see that we get no proper

149
00:09:39,270 --> 00:09:42,592
output because it doesn't know where the cluster is,

150
00:09:42,646 --> 00:09:46,108
right? Where is the API server of the cluster

151
00:09:46,204 --> 00:09:49,904
that we want to get the nodes from. So that's one

152
00:09:49,942 --> 00:09:54,036
thing that we need to specify. So that's the message we see here.

153
00:09:54,138 --> 00:09:57,972
And also we need to pass those certificates to

154
00:09:58,026 --> 00:10:01,540
authenticate with it. And to provide all that we're going to pass

155
00:10:01,610 --> 00:10:05,428
in the Kubeconfig file we want to use. So Kubeconfig

156
00:10:05,524 --> 00:10:11,672
and the location of the

157
00:10:11,726 --> 00:10:15,432
admin conf file. However this

158
00:10:15,486 --> 00:10:19,020
is only accessible to root user. So we're going to do

159
00:10:19,090 --> 00:10:22,716
pseudo here. Now let's execute this command. And there

160
00:10:22,738 --> 00:10:27,448
you go, you see that we connected to the cluster as

161
00:10:27,474 --> 00:10:31,392
well as authenticated with it using this

162
00:10:31,446 --> 00:10:34,832
configuration file. We're going to come back to the output of

163
00:10:34,886 --> 00:10:38,592
this later. Now let's actually learn more

164
00:10:38,646 --> 00:10:41,924
about this Kubeconfig file and let's see how the

165
00:10:41,962 --> 00:10:44,550
contents of this file actually looks like.

166
00:10:47,240 --> 00:10:51,104
So I'm going to copy that and we're going to simply see the contents

167
00:10:51,152 --> 00:10:54,984
of this file. And again we

168
00:10:55,022 --> 00:10:58,584
need pseudo permission. And there

169
00:10:58,622 --> 00:11:02,772
you go, and I'm going to copy this contents.

170
00:11:02,916 --> 00:11:06,984
So this is how the Kubeconfig file contents

171
00:11:07,032 --> 00:11:10,360
actually look like. As you see, this is a Kubernetes

172
00:11:10,440 --> 00:11:13,548
manifest file. We have kind

173
00:11:13,714 --> 00:11:17,480
which is config and we have all this data here.

174
00:11:17,570 --> 00:11:21,264
First of all we have list of clusters and this is

175
00:11:21,302 --> 00:11:24,396
our cluster that we actually have created.

176
00:11:24,508 --> 00:11:27,776
And this is the endpoint or address of

177
00:11:27,798 --> 00:11:31,540
the Kube API server. And if we check this

178
00:11:31,610 --> 00:11:35,828
IP address here 172 ending with 88,

179
00:11:35,994 --> 00:11:39,376
go back. That's actually the private IP

180
00:11:39,408 --> 00:11:43,332
address of our master node. So that's where the Kube API

181
00:11:43,396 --> 00:11:46,932
server is accessible for other applications

182
00:11:47,076 --> 00:11:50,740
within that VPC or private network.

183
00:11:50,900 --> 00:11:54,424
And on that machine the API server is running

184
00:11:54,542 --> 00:11:58,712
on this port. Then we have the certificate authority

185
00:11:58,776 --> 00:12:02,524
data and this is actually the self signed CA

186
00:12:02,642 --> 00:12:06,472
that Kubeadm generates for the cluster.

187
00:12:06,616 --> 00:12:10,284
So this is the contents of the CA certificate

188
00:12:10,332 --> 00:12:14,524
file. So client has to include that CA in the request.

189
00:12:14,652 --> 00:12:18,096
So that's basically our cluster. And then we have

190
00:12:18,278 --> 00:12:21,712
the users, again we have one user,

191
00:12:21,856 --> 00:12:25,984
in this case it was called Kubernetes admin. That's our admin

192
00:12:26,032 --> 00:12:29,712
user and it has client certificate

193
00:12:29,776 --> 00:12:33,252
and client key. So these are basically the client

194
00:12:33,316 --> 00:12:36,792
certificate that was created for the admin and it was

195
00:12:36,846 --> 00:12:40,004
directly put in here because we don't need it anywhere

196
00:12:40,052 --> 00:12:44,120
else. As well as the controller, manager and

197
00:12:44,270 --> 00:12:48,456
scheduler and Kubelet, they have their client certificates

198
00:12:48,648 --> 00:12:52,364
directly in those kubeconfig files. That's why you don't see them

199
00:12:52,402 --> 00:12:56,044
actually here. So client certificate, the CA certificate and the

200
00:12:56,082 --> 00:13:00,044
endpoint of the API server. This is everything that Kubectl

201
00:13:00,092 --> 00:13:03,664
basically needs in order to connect to this cluster and

202
00:13:03,702 --> 00:13:08,048
authenticate with it using these certificates. And finally

203
00:13:08,214 --> 00:13:12,116
you also see an attribute called contexts here

204
00:13:12,218 --> 00:13:15,572
with a current context for the Kubectl that says

205
00:13:15,706 --> 00:13:19,172
connect to the cluster called kubernetes which is defined here.

206
00:13:19,226 --> 00:13:23,344
So this cluster using a user called kubeadm

207
00:13:23,392 --> 00:13:26,564
which is defined right here. So that's basically what a context

208
00:13:26,612 --> 00:13:30,324
says. So if we had multiple clusters and multiple users

209
00:13:30,372 --> 00:13:34,452
here that we connect to using the same Kubectl

210
00:13:34,516 --> 00:13:38,504
tool, we could switch between those clusters and

211
00:13:38,542 --> 00:13:42,044
users using those contexts. But we're going to see

212
00:13:42,162 --> 00:13:45,992
context in practice in one of the later lectures

213
00:13:46,056 --> 00:13:50,252
in detail. So here, just know that we're using context

214
00:13:50,396 --> 00:13:54,144
to choose one of the clusters we want to connect to from the

215
00:13:54,182 --> 00:13:57,584
clusters list using one of the users from

216
00:13:57,622 --> 00:14:01,348
the user's list like this.

217
00:14:01,514 --> 00:14:05,600
So that's basically how any other Kubeconfig

218
00:14:05,680 --> 00:14:09,952
file will look like with just different client certificate

219
00:14:10,096 --> 00:14:13,350
data and username here.

220
00:14:16,100 --> 00:14:19,508
Now as I mentioned, as an administrator you're going to

221
00:14:19,514 --> 00:14:23,430
be working with Kubectl a lot. So you're going to be basically

222
00:14:23,800 --> 00:14:27,016
checking anything and creating and configuring anything in the

223
00:14:27,038 --> 00:14:30,472
cluster using this Kubectl tool. So having

224
00:14:30,526 --> 00:14:33,880
to specify a kubeconfig file on every

225
00:14:33,950 --> 00:14:37,668
single Kubectl command, as well as having to execute

226
00:14:37,684 --> 00:14:41,244
it with pseudo is kind of annoying and

227
00:14:41,362 --> 00:14:44,540
very repetitive. So how can we actually

228
00:14:44,610 --> 00:14:48,092
avoid that? Now there are two alternatives for that. The first one

229
00:14:48,146 --> 00:14:51,788
is setting the Kubeconfig file location

230
00:14:51,884 --> 00:14:55,872
as an environment variable. Now in our case, because this is

231
00:14:56,006 --> 00:14:59,852
a protected folder only accessible for root,

232
00:14:59,996 --> 00:15:03,924
let's switch to the root user like

233
00:15:03,962 --> 00:15:07,840
this and set the environment variable

234
00:15:07,920 --> 00:15:11,680
here which is called kubeconfig.

235
00:15:11,840 --> 00:15:15,376
And this will be pointing to the admin

236
00:15:15,488 --> 00:15:19,304
confile. And now I can execute the

237
00:15:19,342 --> 00:15:23,620
Kubectl without specifying the kubeconfig file.

238
00:15:23,700 --> 00:15:27,256
And this is a nice alternative. However this of

239
00:15:27,278 --> 00:15:30,684
course will only work in the current session and also every time I

240
00:15:30,722 --> 00:15:34,204
reconnect to the machine I'll have to

241
00:15:34,242 --> 00:15:38,044
set this environment variable so it's not persistent. So as

242
00:15:38,162 --> 00:15:42,396
a better alternative we can take that kubeconfig

243
00:15:42,428 --> 00:15:46,252
file and put it in a default location where Kubectl

244
00:15:46,316 --> 00:15:49,744
will actually look for it, and that is in the

245
00:15:49,782 --> 00:15:51,920
user's home directory,

246
00:15:52,740 --> 00:15:56,956
Kubefolder. So that's

247
00:15:56,988 --> 00:16:01,008
the default folder where Kubectl will look for the configuration file.

248
00:16:01,104 --> 00:16:04,964
However we don't have this folder, so let's actually

249
00:16:05,082 --> 00:16:10,152
create it and

250
00:16:10,206 --> 00:16:14,600
let's just copy the admin config file into cube

251
00:16:14,940 --> 00:16:18,216
folder and it should be called config as

252
00:16:18,238 --> 00:16:20,620
a default execute.

253
00:16:22,080 --> 00:16:24,350
And now if I check this,

254
00:16:25,920 --> 00:16:29,516
so I have my config file here. However it is

255
00:16:29,538 --> 00:16:33,212
owned by the root user. So we have to actually make Ubuntu

256
00:16:33,276 --> 00:16:36,624
make our own user an owner of this.

257
00:16:36,822 --> 00:16:38,050
So let's see.

258
00:16:39,860 --> 00:16:43,136
So if I do Idu, this will give

259
00:16:43,158 --> 00:16:47,110
me the id of the current user. And if I

260
00:16:48,520 --> 00:16:51,732
print the id of the group, the current

261
00:16:51,786 --> 00:16:54,230
group, it's also 1000.

262
00:16:54,600 --> 00:16:59,016
Using the root user or pseudo privilege we can actually

263
00:16:59,198 --> 00:17:03,130
make our current user and current group

264
00:17:05,020 --> 00:17:08,036
owner of that file.

265
00:17:08,228 --> 00:17:10,830
Let's execute check again.

266
00:17:12,560 --> 00:17:16,264
And there you go. Instead of root we now have Ubuntu user,

267
00:17:16,312 --> 00:17:19,724
Ubuntu group owning that file. Now we don't have to

268
00:17:19,762 --> 00:17:22,944
use pseudo anymore and we have our

269
00:17:22,982 --> 00:17:26,224
Kubeconfig file in the default location. So if

270
00:17:26,262 --> 00:17:29,836
I do Kubectl get node now with Ubuntu user,

271
00:17:29,948 --> 00:17:33,216
there you go, we get the same result and now

272
00:17:33,238 --> 00:17:37,104
it's persistent. So if we log out and log into the master node

273
00:17:37,152 --> 00:17:39,510
we will still get the same result.

274
00:17:52,130 --> 00:17:55,710
Concepts of kubernetes, which is namespaces,

275
00:17:56,210 --> 00:17:59,410
which we will be using a lot in the upcoming lectures.

276
00:18:02,150 --> 00:18:05,854
First of all, what is a namespace in Kubernetes? In Kubernetes

277
00:18:05,902 --> 00:18:09,742
cluster you can organize resources in namespaces,

278
00:18:09,806 --> 00:18:13,606
so you can have multiple namespaces in a cluster. You can think of

279
00:18:13,628 --> 00:18:17,154
a namespace as a virtual cluster inside of a Kubernetes

280
00:18:17,202 --> 00:18:19,842
cluster. Now when you create a cluster,

281
00:18:19,986 --> 00:18:23,846
by default, Kubernetes gives you namespaces out

282
00:18:23,868 --> 00:18:28,486
of the box. So in the command line if I type Kubectl get namespaces,

283
00:18:28,598 --> 00:18:32,742
I see the list of those out of the box namespaces that Kubernetes

284
00:18:32,806 --> 00:18:36,506
offers. But of course you can add and create new namespaces

285
00:18:36,618 --> 00:18:40,170
and the way that you can do it is using Kubectl

286
00:18:40,250 --> 00:18:44,234
create namespace command with the name of the namespace

287
00:18:44,362 --> 00:18:47,390
so I can create my namespace.

288
00:18:47,550 --> 00:18:51,426
And if I do Kubectl get namespaces, I see

289
00:18:51,448 --> 00:18:54,894
that in my list. Now another way to create namespaces

290
00:18:55,022 --> 00:18:58,750
is using a namespace configuration file,

291
00:18:58,830 --> 00:19:01,974
which I think is a better way to create namespaces because

292
00:19:02,012 --> 00:19:06,290
you also have a history in your configuration file repository

293
00:19:06,370 --> 00:19:09,842
of what resources you created in a cluster.

294
00:19:09,986 --> 00:19:14,166
Okay, so now we saw what namespaces are and that

295
00:19:14,188 --> 00:19:17,798
you can create new ones and that Kubernetes offers some of them by default.

296
00:19:17,894 --> 00:19:21,814
But the question is what is the need for namespaces?

297
00:19:21,942 --> 00:19:25,886
When should you create them and how you should use them. The first

298
00:19:25,988 --> 00:19:30,046
use case of using or creating your own namespaces is

299
00:19:30,148 --> 00:19:33,866
the following. Imagine you have only default namespace

300
00:19:33,898 --> 00:19:37,234
which is provided by Kubernetes and you create all your

301
00:19:37,272 --> 00:19:41,490
resources in that default namespace. If you have a complex application

302
00:19:41,640 --> 00:19:45,314
that has multiple deployments which create replicas of

303
00:19:45,352 --> 00:19:48,962
many pods, and you have resources like services

304
00:19:49,096 --> 00:19:52,978
and config maps, et cetera, very soon your default namespace

305
00:19:52,994 --> 00:19:56,326
is going to be filled with different components and it will be

306
00:19:56,348 --> 00:20:00,166
really difficult to have an overview of what's in there,

307
00:20:00,268 --> 00:20:03,338
especially if you have multiple users creating stuff inside.

308
00:20:03,504 --> 00:20:07,082
So a better way to use namespaces in this case

309
00:20:07,216 --> 00:20:11,254
is to group resources into namespaces.

310
00:20:11,302 --> 00:20:15,342
So for example, you can have a database namespace where you deploy your

311
00:20:15,396 --> 00:20:19,098
database and all its required resources,

312
00:20:19,194 --> 00:20:22,746
and you can have a monitoring namespace where you deploy

313
00:20:22,778 --> 00:20:26,094
the prometheus and all the stuff that it needs. You can also

314
00:20:26,132 --> 00:20:30,238
have elasticstack namespace where all the elasticsearch,

315
00:20:30,334 --> 00:20:33,506
Kibana, etc. Resources go, and you

316
00:20:33,528 --> 00:20:37,394
can have Nginx ingress resources. So just one way of

317
00:20:37,432 --> 00:20:40,486
logically grouping your resources inside of

318
00:20:40,508 --> 00:20:43,522
the cluster. Now, according to the official

319
00:20:43,586 --> 00:20:46,994
documentation of Kubernetes, you shouldn't

320
00:20:47,042 --> 00:20:50,760
use namespaces if you have smaller projects and

321
00:20:51,130 --> 00:20:54,442
up to ten users. I personally think

322
00:20:54,496 --> 00:20:58,518
that it's always good idea to group your resources

323
00:20:58,614 --> 00:21:02,058
in namespaces because as I said, even if you

324
00:21:02,064 --> 00:21:06,382
have a small project and ten users, you might still

325
00:21:06,516 --> 00:21:10,442
need some additional resources for your application, like logging

326
00:21:10,506 --> 00:21:13,998
system and monitoring system. And even with a

327
00:21:14,004 --> 00:21:17,678
minimum setup, it can already get too much to just

328
00:21:17,764 --> 00:21:21,202
throw everything in a default namespace. Another use case where

329
00:21:21,256 --> 00:21:24,638
you will need to use namespace is if you have multiple teams.

330
00:21:24,734 --> 00:21:28,706
So imagine this scenario. You have two teams that use the

331
00:21:28,728 --> 00:21:32,774
same cluster, and one team deploys an

332
00:21:32,812 --> 00:21:36,438
application which is called MyApp deployment. That's the name of

333
00:21:36,444 --> 00:21:40,070
the deployment they create, and that deployment has its certain

334
00:21:40,140 --> 00:21:44,262
configuration. Now if another team had a deployment

335
00:21:44,326 --> 00:21:47,690
that accidentally had the same name but

336
00:21:47,760 --> 00:21:51,734
a different configuration, and they created that deployment,

337
00:21:51,782 --> 00:21:56,282
or they applied it, they would overwrite the first team's

338
00:21:56,346 --> 00:21:59,806
deployment. And if they're using, for example a

339
00:21:59,828 --> 00:22:03,694
Jenkins or some automated way to deploy that

340
00:22:03,732 --> 00:22:07,570
application or to create that deployment, they wouldn't even know that

341
00:22:07,640 --> 00:22:11,438
they overwrote or disrupted another team's deployment.

342
00:22:11,534 --> 00:22:16,030
So to avoid such kind of conflicts, again, you can use namespaces

343
00:22:16,190 --> 00:22:20,130
so that each team can work in their own namespace

344
00:22:20,210 --> 00:22:23,782
without disrupting the other. Another use case for using

345
00:22:23,836 --> 00:22:27,526
namespaces is let's say you have one cluster and you

346
00:22:27,548 --> 00:22:31,410
want to host both staging and development environment

347
00:22:31,490 --> 00:22:34,970
in the same cluster. And the reason for that is that, for example,

348
00:22:35,040 --> 00:22:38,458
if you're using something like NgInX controller or

349
00:22:38,544 --> 00:22:41,642
Elasticstack used for logging, for example,

350
00:22:41,776 --> 00:22:44,934
you can deploy it in one cluster and use it for both

351
00:22:44,992 --> 00:22:48,638
environments. In that way you don't have to deploy these common

352
00:22:48,724 --> 00:22:51,962
resources twice in two different clusters.

353
00:22:52,106 --> 00:22:55,646
So now the staging can use both resources as well

354
00:22:55,668 --> 00:22:58,946
as the development environment. Another use case

355
00:22:59,048 --> 00:23:02,334
for using namespaces is when you use blue green deployment

356
00:23:02,382 --> 00:23:06,114
for application, which means that in the same cluster you

357
00:23:06,152 --> 00:23:09,314
want to have two different versions of

358
00:23:09,432 --> 00:23:12,882
production. So the one that is active, that is in production

359
00:23:12,946 --> 00:23:16,514
now, and another one that is going to be the next production

360
00:23:16,562 --> 00:23:19,906
version. The versions of the applications in those blue

361
00:23:19,938 --> 00:23:22,390
and green production namespaces will be different,

362
00:23:22,540 --> 00:23:26,610
however, the same as we saw before in staging and development.

363
00:23:26,770 --> 00:23:30,806
These namespaces might need to use the same resources

364
00:23:30,998 --> 00:23:35,010
like again NginX controller or Elasticstack,

365
00:23:35,110 --> 00:23:38,986
and this way again they can both use the common shared

366
00:23:39,018 --> 00:23:42,570
resources without having to set up a separate cluster.

367
00:23:42,650 --> 00:23:46,558
So one more use case for using namespaces is to

368
00:23:46,644 --> 00:23:50,322
limit the resources and access to

369
00:23:50,376 --> 00:23:53,198
namespaces when you're working with multiple teams.

370
00:23:53,294 --> 00:23:56,754
So again, we have a scenario where we have two teams working in the same

371
00:23:56,792 --> 00:24:00,366
cluster and each one of them has their own namespace.

372
00:24:00,478 --> 00:24:04,306
So what you can do in this scenario is that you can give the teams

373
00:24:04,418 --> 00:24:08,102
access to only their namespace, so they can only be able

374
00:24:08,156 --> 00:24:11,994
to create updates, delete resources in their own

375
00:24:12,032 --> 00:24:16,070
namespace, but they can't do anything in the other namespaces.

376
00:24:16,150 --> 00:24:19,606
In this way, you even restrict or even minimize the risk

377
00:24:19,638 --> 00:24:23,130
of one team accidentally interfering with

378
00:24:23,200 --> 00:24:26,874
another team's work. So each one has their own secured

379
00:24:27,002 --> 00:24:30,158
isolated environment. Additional thing that you can do on

380
00:24:30,164 --> 00:24:34,426
a namespace level is limit the resources that each namespace

381
00:24:34,458 --> 00:24:38,046
consumes. Because if you have a cluster with limited resources,

382
00:24:38,158 --> 00:24:42,354
you want to give each team a share of resources for

383
00:24:42,392 --> 00:24:45,698
their application. So if one team, let's say,

384
00:24:45,784 --> 00:24:49,502
consumes too much resources, then other teams will eventually

385
00:24:49,566 --> 00:24:53,366
have much less and their applications may not schedule because the

386
00:24:53,388 --> 00:24:57,302
cluster will run out of the resources. So what you can do is that per

387
00:24:57,356 --> 00:25:01,318
namespace you can define resource quotas that limit how much

388
00:25:01,404 --> 00:25:04,854
cpu ram storage resources one namespace

389
00:25:04,902 --> 00:25:09,190
can use. So I hope walking through these scenarios helped you analyze

390
00:25:09,270 --> 00:25:13,498
in which use cases and how you should use namespaces in your specific

391
00:25:13,584 --> 00:25:17,310
project. There are several characteristics that you should consider before

392
00:25:17,380 --> 00:25:20,734
deciding how to group and how to use namespaces. The first

393
00:25:20,772 --> 00:25:24,862
one is that you can't access most of the resources from another

394
00:25:24,916 --> 00:25:28,782
namespace. So for example, if you have a configuration

395
00:25:28,846 --> 00:25:33,038
map in project a namespace that references the database

396
00:25:33,134 --> 00:25:37,090
service, you can't use that config map in project

397
00:25:37,160 --> 00:25:41,250
B namespace, but instead you will have to create the same config map

398
00:25:41,330 --> 00:25:44,950
that also references the database service. So each

399
00:25:45,100 --> 00:25:48,902
namespace will define, or must define its own

400
00:25:48,956 --> 00:25:52,294
config map, even if it's the same reference. And the same

401
00:25:52,332 --> 00:25:55,782
applies to secret. So for example, if you have credentials

402
00:25:55,846 --> 00:25:59,482
of a shared service, you will have to create that secret in each

403
00:25:59,536 --> 00:26:02,890
namespace where you are going to need that. However,

404
00:26:03,040 --> 00:26:07,086
a resource that you can share across namespaces is

405
00:26:07,188 --> 00:26:10,010
service, and that's what we saw in the previous slide.

406
00:26:10,090 --> 00:26:13,978
So config map in project b namespace references

407
00:26:14,154 --> 00:26:18,114
service that is going to be used eventually in a pod. And the way it

408
00:26:18,152 --> 00:26:21,950
works is that in a config map definition, the database URL

409
00:26:22,030 --> 00:26:26,510
in addition to its name, which is MySQl service, will have namespace

410
00:26:26,590 --> 00:26:30,518
at the end. So using that URL you can actually access

411
00:26:30,604 --> 00:26:33,586
services from other namespaces,

412
00:26:33,698 --> 00:26:36,886
which is a very practical thing. And this is how you

413
00:26:36,908 --> 00:26:40,546
can actually use shared resources like elasticsearch

414
00:26:40,658 --> 00:26:44,294
or Nginx from other namespaces.

415
00:26:44,422 --> 00:26:47,706
And one more characteristic is that we saw that most of the

416
00:26:47,728 --> 00:26:51,910
components resources can be created within a namespace,

417
00:26:51,990 --> 00:26:56,282
but there are some components in Kubernetes, they're not namespaced,

418
00:26:56,346 --> 00:27:00,522
so to say. So basically they live just globally

419
00:27:00,586 --> 00:27:04,014
in the cluster, and you can't isolate them or

420
00:27:04,052 --> 00:27:07,914
put them in a certain namespace. And examples of such resources

421
00:27:07,962 --> 00:27:12,066
are volume or persistent volume and node. So basically when

422
00:27:12,088 --> 00:27:15,902
you create the volume, it's going to be accessible throughout the whole cluster,

423
00:27:16,046 --> 00:27:19,922
because it's not in a namespace. And you can actually list

424
00:27:20,056 --> 00:27:23,302
components, they're not bound to a namespace using

425
00:27:23,356 --> 00:27:28,066
a command. Kubectl API resources namespace

426
00:27:28,178 --> 00:27:31,886
false. And the same way you can also list all the resources

427
00:27:31,938 --> 00:27:35,302
that are bound to a namespace using namespace.

428
00:27:35,366 --> 00:27:50,408
True namespaces

429
00:27:50,504 --> 00:27:53,884
are and how they are used. Let's actually check in our

430
00:27:53,922 --> 00:27:57,744
cluster what namespaces we have and what pods are running in those

431
00:27:57,782 --> 00:28:01,824
namespaces. So first of all, I'm back on my master node where I

432
00:28:01,862 --> 00:28:05,420
have Kubeconfig file already configured in the default

433
00:28:05,500 --> 00:28:09,332
location. So I'm going to execute Kubectl get

434
00:28:09,466 --> 00:28:13,424
namespaces or short NS command,

435
00:28:13,552 --> 00:28:17,636
and this will give me a list of the namespaces that have

436
00:28:17,658 --> 00:28:21,156
been created in my cluster. This is the default namespace

437
00:28:21,188 --> 00:28:24,680
that you can deploy your applications inside.

438
00:28:24,830 --> 00:28:28,084
Then we have Kubenode, lease, Kubelic,

439
00:28:28,132 --> 00:28:31,640
and Kube system namespaces. We're not going to need to

440
00:28:31,710 --> 00:28:36,168
check or add something or do anything with those two namespaces

441
00:28:36,264 --> 00:28:40,744
so we can ignore them and look at those two namespaces.

442
00:28:40,872 --> 00:28:44,696
The default namespace, as I said, is where you can start deploying

443
00:28:44,728 --> 00:28:48,320
your applications. So if I do Kubectl get

444
00:28:48,470 --> 00:28:51,776
pod, which is a command for listing all the

445
00:28:51,798 --> 00:28:55,216
pods running in the cluster, you will see that it

446
00:28:55,238 --> 00:28:59,696
gives me zero results, no resources found in default namespaces.

447
00:28:59,808 --> 00:29:03,712
And that means that by default this command

448
00:29:03,776 --> 00:29:07,056
for listing pods and services, et cetera,

449
00:29:07,168 --> 00:29:10,824
or kubernetes, resources that are living

450
00:29:10,862 --> 00:29:14,932
in namespaces will always use the default namespace.

451
00:29:15,076 --> 00:29:19,220
How do I see pods running in the Kube system namespace?

452
00:29:19,380 --> 00:29:23,456
For that I can specify a namespace with my Kubectl

453
00:29:23,508 --> 00:29:27,468
get Kubernetes resource name command and

454
00:29:27,634 --> 00:29:31,150
name of the namespace. So this will basically

455
00:29:31,680 --> 00:29:36,196
list all the pods running in this specific namespace.

456
00:29:36,328 --> 00:29:40,592
And here are all the control plane pods that

457
00:29:40,646 --> 00:29:43,824
were created as manifests and

458
00:29:43,942 --> 00:29:47,564
deployed as static pods. We have Kube

459
00:29:47,612 --> 00:29:51,244
API server, we have the Kubecontroller manager,

460
00:29:51,372 --> 00:29:54,692
Kube scheduler and ECD. And you

461
00:29:54,746 --> 00:29:58,516
notice that at the end of each of these pods we have

462
00:29:58,538 --> 00:30:02,416
this suffix master. And this

463
00:30:02,458 --> 00:30:06,596
is an indicator that these are static pods, because static pods,

464
00:30:06,628 --> 00:30:10,680
as I mentioned, get a suffix at the end of the name

465
00:30:10,750 --> 00:30:14,036
of the node where they're scheduled on. And also

466
00:30:14,078 --> 00:30:17,628
you saw we had the static pod manifest for them, and as you

467
00:30:17,634 --> 00:30:21,868
see they are in a running state and we have

468
00:30:22,034 --> 00:30:25,688
one container out of one successfully running.

469
00:30:25,794 --> 00:30:29,552
Everything seems great. Now, in addition to those

470
00:30:29,686 --> 00:30:32,796
four control plane components,

471
00:30:32,908 --> 00:30:36,188
we have another one called kubeproxy,

472
00:30:36,284 --> 00:30:39,744
which is not a static pod, it doesn't have a

473
00:30:39,782 --> 00:30:43,532
master suffix, and we also have core DNS

474
00:30:43,676 --> 00:30:47,668
pod, two of them, right, two replicas. And remember,

475
00:30:47,834 --> 00:30:51,476
in the output of Kubeadm init, we had

476
00:30:51,578 --> 00:30:55,704
two atoms that were installed at the end of the

477
00:30:55,742 --> 00:30:59,368
cluster setup. So once the master nodes were up and running,

478
00:30:59,534 --> 00:31:02,660
those two pods were actually scheduled.

479
00:31:02,740 --> 00:31:06,008
Qproxy runs as a regular pod,

480
00:31:06,104 --> 00:31:10,296
as you see it is in the running state, and two replicas

481
00:31:10,408 --> 00:31:13,864
of core DNS pods. And all these pods

482
00:31:13,912 --> 00:31:17,392
are running on the master node. Because we

483
00:31:17,446 --> 00:31:21,584
only have one node in the cluster which

484
00:31:21,622 --> 00:31:23,120
is the master node.

485
00:31:26,980 --> 00:31:30,336
You need to understand how networking works in Kubernetes,

486
00:31:30,448 --> 00:31:34,064
which is a very interesting but also a complex topic.

487
00:31:34,192 --> 00:31:37,424
However, in order to understand networking in kubernetes,

488
00:31:37,552 --> 00:31:40,724
you need to have basic knowledge of networking in

489
00:31:40,762 --> 00:31:44,724
general. So in this lecture we will cover the basic concepts

490
00:31:44,772 --> 00:31:48,200
of networking. How does computer networks work?

491
00:31:48,350 --> 00:31:51,736
How do computers connect to the Internet? What is an

492
00:31:51,758 --> 00:31:54,924
IP address and a port? And so on. We will

493
00:31:54,962 --> 00:31:58,844
learn all of this in this lecture where I will explain all the main

494
00:31:58,882 --> 00:32:02,024
concepts step by step with examples.

495
00:32:02,152 --> 00:32:03,470
So let's get started.

496
00:32:06,440 --> 00:32:10,424
First of all, imagine your home network for your house where

497
00:32:10,462 --> 00:32:14,964
different devices like your computer and laptop and phone are connected

498
00:32:15,092 --> 00:32:18,708
to that network. Such a network is called a lEn

499
00:32:18,804 --> 00:32:22,968
or local area network. So Len is a network

500
00:32:23,064 --> 00:32:26,968
of a bunch of devices connected together in one physical

501
00:32:27,064 --> 00:32:30,700
location. This can be as small as a private house,

502
00:32:30,770 --> 00:32:34,672
len or len of a huge office building or a school

503
00:32:34,726 --> 00:32:38,784
campus with hundreds of devices. And each device on this

504
00:32:38,822 --> 00:32:42,796
network is identified by a unique IP

505
00:32:42,908 --> 00:32:46,800
address where IP stands for Internet protocol.

506
00:32:46,880 --> 00:32:50,464
So devices can talk to each other on the network

507
00:32:50,592 --> 00:32:53,780
using this unique IP address. For example,

508
00:32:53,850 --> 00:32:57,224
if your computer wants to send a printer something to

509
00:32:57,262 --> 00:33:01,144
print, it must know the printer's IP address and send the

510
00:33:01,182 --> 00:33:04,804
information there. This is an example of an IP

511
00:33:04,852 --> 00:33:08,516
address 170 2160

512
00:33:08,628 --> 00:33:12,636
zero. So IP address is basically

513
00:33:12,818 --> 00:33:15,356
a 32 bit value.

514
00:33:15,538 --> 00:33:19,292
One bit is essentially a value of one or zero.

515
00:33:19,426 --> 00:33:22,924
Now we don't need to go into details here, but important to know

516
00:33:22,962 --> 00:33:26,320
that an IP address or IPV four

517
00:33:26,390 --> 00:33:30,428
address is composed of 32 bits.

518
00:33:30,524 --> 00:33:33,964
So basically 32 ones or zeros

519
00:33:34,012 --> 00:33:37,380
here. And what are those dots between them? Well,

520
00:33:37,450 --> 00:33:41,264
every eight bits are grouped into an octet

521
00:33:41,392 --> 00:33:44,864
and each octet can be represented as a decimal

522
00:33:44,912 --> 00:33:47,880
number that we humans can read.

523
00:33:48,030 --> 00:33:52,280
Like this octet here represents 172,

524
00:33:52,430 --> 00:33:56,212
this one represents 16 and so on. So octet

525
00:33:56,276 --> 00:34:00,428
with all zeros, so eight zeros is

526
00:34:00,594 --> 00:34:03,900
just a zero and an octet with

527
00:34:03,970 --> 00:34:07,948
all ones, so eight ones is a number.

528
00:34:08,114 --> 00:34:11,292
255. That means that

529
00:34:11,346 --> 00:34:15,776
IP address value can be any combination between zero,

530
00:34:15,878 --> 00:34:20,048
zero and 255.

531
00:34:20,214 --> 00:34:24,368
255 dot 255 255.

532
00:34:24,454 --> 00:34:27,844
So that's how IP address is made up. But how do

533
00:34:27,882 --> 00:34:31,556
devices know each other's IP addresses? Or how

534
00:34:31,578 --> 00:34:35,056
can they send things to each other? Well, that is a task

535
00:34:35,088 --> 00:34:38,804
of a special device on a local area network called a

536
00:34:38,842 --> 00:34:42,824
switch. So switch sits within the lane and

537
00:34:42,862 --> 00:34:47,172
knows all the IP addresses of all the devices and therefore

538
00:34:47,236 --> 00:34:50,888
helps them communicate with each other within that local

539
00:34:50,974 --> 00:34:54,844
area network. Great. So your laptop can talk to a phone or

540
00:34:54,882 --> 00:34:58,236
a printer in Len using a switch. But what if

541
00:34:58,258 --> 00:35:01,544
you want to talk to a server or some other device

542
00:35:01,592 --> 00:35:05,324
which is not in your len? Like you want to open Facebook

543
00:35:05,452 --> 00:35:09,024
website on your laptop. So you need to connect to and talk

544
00:35:09,062 --> 00:35:12,496
to a Facebook server which is obviously

545
00:35:12,598 --> 00:35:16,064
outside your len or essentially any website which is

546
00:35:16,102 --> 00:35:19,344
hosted on a server outside your len. Does switch

547
00:35:19,392 --> 00:35:23,200
help there too? No. For connecting to outside devices,

548
00:35:23,360 --> 00:35:26,984
there is another special device in a lane called a

549
00:35:27,022 --> 00:35:30,232
router. Router is a network device that

550
00:35:30,286 --> 00:35:34,500
sits between the local area network and the outside network,

551
00:35:34,660 --> 00:35:38,296
which is also called a wide area network or

552
00:35:38,398 --> 00:35:42,252
win. So the router connects devices on local area

553
00:35:42,306 --> 00:35:46,136
network and wide area network, which means the router connects

554
00:35:46,168 --> 00:35:49,836
you to the Internet. Back to our Facebook example, if you

555
00:35:49,858 --> 00:35:53,584
want to open Facebook app on your phone, your phone will send a

556
00:35:53,622 --> 00:35:56,704
request to the router. Then router will send

557
00:35:56,742 --> 00:35:59,756
that request to Facebook server over the Internet,

558
00:35:59,868 --> 00:36:03,024
and the IP address of the router is called a

559
00:36:03,062 --> 00:36:06,784
gateway. So when you hear the term router and network

560
00:36:06,832 --> 00:36:09,030
gateway are basically the same thing.

561
00:36:11,800 --> 00:36:15,232
Now the question is, when a device in LEN

562
00:36:15,376 --> 00:36:18,856
sends a request to another device, how does

563
00:36:18,878 --> 00:36:23,204
it know whether that other device is within the lane or it's

564
00:36:23,252 --> 00:36:26,404
outside the lane in the wide area network?

565
00:36:26,532 --> 00:36:30,212
Well, this is decided based on the IP address of the target

566
00:36:30,276 --> 00:36:34,156
device. Remember, as I said, that every device on land has

567
00:36:34,178 --> 00:36:37,592
a unique IP address? Well, these IP addresses

568
00:36:37,656 --> 00:36:41,004
aren't random. They all belong to the same

569
00:36:41,122 --> 00:36:44,620
range of IP addresses to identify

570
00:36:44,700 --> 00:36:49,004
devices in the same network. And that IP address range

571
00:36:49,132 --> 00:36:52,972
is represented by a concept called subnet

572
00:36:53,116 --> 00:36:56,416
or subnetwork. This is how an IP

573
00:36:56,448 --> 00:37:00,372
address range for a lan can look like.

574
00:37:00,506 --> 00:37:03,636
So the first part here is the IP address,

575
00:37:03,818 --> 00:37:07,388
and that's the starting point of the IP address range.

576
00:37:07,424 --> 00:37:10,504
So that's the first IP address in the range. And the

577
00:37:10,542 --> 00:37:14,068
second one is what's called a subnet mask.

578
00:37:14,164 --> 00:37:17,224
So subnet basically sets the range and

579
00:37:17,262 --> 00:37:20,716
it defines that whatever IP address of a

580
00:37:20,738 --> 00:37:29,660
device starts with 192.1680.

581
00:37:29,810 --> 00:37:33,944
So whenever an IP address starts with this, it belongs

582
00:37:33,992 --> 00:37:37,744
to the lan. If we change the subnet mask value

583
00:37:37,862 --> 00:37:41,200
from 255 dot 255

584
00:37:41,270 --> 00:37:44,464
dot 2550 to

585
00:37:44,582 --> 00:37:47,988
255 dot 2550 zero,

586
00:37:48,154 --> 00:37:51,620
then this will define an IP address range that

587
00:37:51,690 --> 00:37:56,592
starts with 192 168.

588
00:37:56,746 --> 00:38:01,192
So all the IP addresses that starts with these two numbers

589
00:38:01,326 --> 00:38:06,936
belong to the same len. So as you see, the value 255

590
00:38:07,118 --> 00:38:11,132
fixates the IP block or

591
00:38:11,186 --> 00:38:14,940
octet, and the value of zero means

592
00:38:15,010 --> 00:38:19,020
a free range. Why 255 and zero?

593
00:38:19,090 --> 00:38:22,784
Because as you learned, each IP decimal block can

594
00:38:22,822 --> 00:38:26,704
have values from zero to 255,

595
00:38:26,822 --> 00:38:30,256
so anything within that range. So basically,

596
00:38:30,358 --> 00:38:34,184
subnet defines how many bits in the IP

597
00:38:34,252 --> 00:38:37,860
address are fixed, making the rest of them

598
00:38:37,930 --> 00:38:41,988
flexible. So 255 dot 2550

599
00:38:42,074 --> 00:38:46,000
zero means that half of it or 16

600
00:38:46,080 --> 00:38:49,944
bits are fixed in the IP address. This, on the other hand,

601
00:38:49,982 --> 00:38:54,184
means that third of all the bits or 24

602
00:38:54,222 --> 00:38:57,592
bits are fixed in the IP address. So again,

603
00:38:57,726 --> 00:39:01,336
when we're using this as a subnet mask,

604
00:39:01,448 --> 00:39:05,592
it means that those first three octets

605
00:39:05,736 --> 00:39:09,148
or decimal values cannot change. Right? So the

606
00:39:09,154 --> 00:39:12,864
IP addresses of this land here will be

607
00:39:12,982 --> 00:39:17,408
between 192 dot 168

608
00:39:17,494 --> 00:39:20,960
dot zero. So the first three cannot change,

609
00:39:21,030 --> 00:39:24,336
they are fixated and the last one

610
00:39:24,518 --> 00:39:28,052
can change and it could be all the way up to 255.

611
00:39:28,186 --> 00:39:32,112
So your IP addresses will be within those ranges.

612
00:39:32,256 --> 00:39:35,616
And right here we have only half of it fixated.

613
00:39:35,728 --> 00:39:39,880
So your IP addresses of this len will be from

614
00:39:39,950 --> 00:39:44,568
this IP address to 255

615
00:39:44,654 --> 00:39:47,860
255. So within this range.

616
00:39:47,940 --> 00:39:51,496
That's how it works. And as we said, this subnet

617
00:39:51,528 --> 00:39:55,528
mask number basically dictates how many bits

618
00:39:55,624 --> 00:39:59,084
in this 32 bit IP address are fixed. So based

619
00:39:59,122 --> 00:40:02,444
on this logic, there is actually a shorthand way of writing

620
00:40:02,492 --> 00:40:06,476
this, which is also called a cider block and is written

621
00:40:06,588 --> 00:40:10,130
like this. So the same IP address as we have here,

622
00:40:10,900 --> 00:40:14,912
16 or 24, where 16

623
00:40:14,976 --> 00:40:18,752
and 24 represent the number of bits

624
00:40:18,816 --> 00:40:22,544
in the IP address range that are fixed.

625
00:40:22,672 --> 00:40:26,096
Just to recap, with subnet and a starting IP

626
00:40:26,128 --> 00:40:29,572
address, we have a range of IP addresses

627
00:40:29,716 --> 00:40:33,464
that are available in the lane. So every device in

628
00:40:33,502 --> 00:40:37,416
that local area network will get an IP address

629
00:40:37,598 --> 00:40:41,256
from that range. So when we send a request to

630
00:40:41,278 --> 00:40:44,396
an IP address within our lan, the request will

631
00:40:44,418 --> 00:40:48,124
go to the switch and it will forward it to the device within the

632
00:40:48,162 --> 00:40:51,784
land. If the IP address is external, it will go to the

633
00:40:51,842 --> 00:40:55,024
Internet through the router. And that means any

634
00:40:55,062 --> 00:40:59,056
device on your network will need three pieces of data

635
00:40:59,158 --> 00:41:03,340
to communicate with other devices, both within its own network

636
00:41:03,420 --> 00:41:06,912
and to the outside network's devices.

637
00:41:07,056 --> 00:41:10,308
And this is the IP address subnet and

638
00:41:10,394 --> 00:41:11,300
gateway.

639
00:41:14,040 --> 00:41:17,876
Now we said that internally in a lan, we have an IP

640
00:41:17,908 --> 00:41:21,544
address range that a network administrator of a

641
00:41:21,582 --> 00:41:24,856
company or school or in case of

642
00:41:24,878 --> 00:41:28,084
your own house, your Internet provider

643
00:41:28,212 --> 00:41:31,816
chooses, and that each device will get a unique IP

644
00:41:31,848 --> 00:41:35,192
address from that range? And suppose a device

645
00:41:35,256 --> 00:41:38,844
in our land is talking to a device in another land.

646
00:41:38,962 --> 00:41:42,232
Now how do we make sure not every network

647
00:41:42,296 --> 00:41:45,536
administrator selects the same range and that the

648
00:41:45,558 --> 00:41:49,356
IP addresses in our land don't overlap

649
00:41:49,468 --> 00:41:52,384
or aren't the same as someone else's land?

650
00:41:52,502 --> 00:41:56,732
Well, the way it works is that the IP addresses of devices

651
00:41:56,876 --> 00:42:00,164
that belong to a land are not visible to

652
00:42:00,202 --> 00:42:04,164
the outside network or Internet. So when you send a request to

653
00:42:04,202 --> 00:42:07,684
Facebook from your laptop, your laptop's IP address from

654
00:42:07,722 --> 00:42:11,668
the lan range does not arrive at Facebook server.

655
00:42:11,844 --> 00:42:15,332
Instead it's replaced by the IP address of the router.

656
00:42:15,396 --> 00:42:18,740
And this functionality of router is called a network

657
00:42:18,820 --> 00:42:23,004
address translation or net. So basically when a

658
00:42:23,042 --> 00:42:26,984
laptop sends a request, it goes to the router, because router

659
00:42:27,032 --> 00:42:30,792
is the connection to the outside network, right to Internet.

660
00:42:30,936 --> 00:42:34,956
And router will then request that on the device's behalf

661
00:42:35,148 --> 00:42:38,416
from Internet and the response will then be

662
00:42:38,438 --> 00:42:41,584
sent back to the device. And that is a

663
00:42:41,622 --> 00:42:44,908
very important concept and has two main advantages.

664
00:42:45,084 --> 00:42:48,932
One of them is security and protection of devices on the land because

665
00:42:48,986 --> 00:42:52,484
your IP address isn't directly exposed and no one can talk to

666
00:42:52,522 --> 00:42:56,240
it directly. And the second one is that we can reuse

667
00:42:56,320 --> 00:43:00,900
IP address ranges multiple times without conflicting

668
00:43:00,980 --> 00:43:04,664
with each other. So two huge companies can

669
00:43:04,702 --> 00:43:08,280
have the same IP address range within their own

670
00:43:08,430 --> 00:43:11,884
local area network and they will basically not know about

671
00:43:11,922 --> 00:43:15,800
each other. So there will be no conflict. And this is very efficient

672
00:43:15,880 --> 00:43:19,176
because there are a limited number of IP

673
00:43:19,208 --> 00:43:22,936
addresses you get from the IPV

674
00:43:23,048 --> 00:43:26,956
four address range, which is as we saw, four zeros.

675
00:43:26,988 --> 00:43:30,268
And sure there are lots

676
00:43:30,284 --> 00:43:33,984
of combinations between them. However, there are also lots and

677
00:43:34,022 --> 00:43:37,216
lots of devices in the world that need IP

678
00:43:37,248 --> 00:43:38,100
addresses.

679
00:43:40,840 --> 00:43:44,960
Now what if an outside device wants to talk to your lan directly?

680
00:43:45,120 --> 00:43:48,676
Like you have a server that runs your application, so you want

681
00:43:48,698 --> 00:43:52,372
to be able to accept requests from devices outside your

682
00:43:52,426 --> 00:43:56,516
lan. Well, by default this kind of communication will not be allowed

683
00:43:56,628 --> 00:44:00,088
because of a firewall. So what is a firewall?

684
00:44:00,184 --> 00:44:04,012
Firewall is a set of rules that protect a network from

685
00:44:04,066 --> 00:44:07,464
unauthorized access. And you can explicitly

686
00:44:07,512 --> 00:44:10,716
define what kind of communication you want to allow to

687
00:44:10,738 --> 00:44:13,996
your network using firewall rules.

688
00:44:14,108 --> 00:44:18,108
So how does it work? You define which device on your network

689
00:44:18,204 --> 00:44:21,644
with a specific IP address should be accessible.

690
00:44:21,772 --> 00:44:25,424
You can also define which other devices or what

691
00:44:25,462 --> 00:44:28,708
IP addresses specifically can access your

692
00:44:28,794 --> 00:44:32,336
server. Or you can say, I allow any device on the Internet

693
00:44:32,368 --> 00:44:35,796
to talk to my server. And this is usually the case when you're running a

694
00:44:35,818 --> 00:44:39,064
web application because you want everyone to be able to

695
00:44:39,102 --> 00:44:42,696
access your application. So for most servers that are running some

696
00:44:42,718 --> 00:44:46,184
applications, you will need to configure firewall rules to

697
00:44:46,222 --> 00:44:49,488
manage the access configuration.

698
00:44:49,604 --> 00:44:53,272
Now there is one more important thing that you always define

699
00:44:53,336 --> 00:44:56,908
in a firewall rule, and that is which

700
00:44:56,994 --> 00:45:00,428
ports are accessible on the server or

701
00:45:00,514 --> 00:45:04,448
generally on the device that you want to allow access to.

702
00:45:04,534 --> 00:45:06,370
So what is a port?

703
00:45:09,460 --> 00:45:13,296
Every device has a set of ports and ports are

704
00:45:13,318 --> 00:45:16,656
like doors to the same building. You unlock

705
00:45:16,768 --> 00:45:20,916
some doors so the guests or requests can enter and

706
00:45:20,938 --> 00:45:24,404
you keep others locked so no one can enter there.

707
00:45:24,522 --> 00:45:28,916
Or you unlock them only for specific guests,

708
00:45:29,028 --> 00:45:32,504
like a specific IP address that can

709
00:45:32,622 --> 00:45:36,660
enter that door, so to say. So with firewall configuration,

710
00:45:36,820 --> 00:45:40,952
you define which doors of the building or your server.

711
00:45:41,016 --> 00:45:44,508
In this case you want to unlock and for

712
00:45:44,594 --> 00:45:48,616
which guests or for what request. And different applications

713
00:45:48,648 --> 00:45:52,430
and programs that run on the server will start

714
00:45:52,820 --> 00:45:55,628
or listen on different ports,

715
00:45:55,724 --> 00:45:59,020
meaning you can access that application on the device

716
00:45:59,180 --> 00:46:03,136
only on that specific port. And to keep this all

717
00:46:03,238 --> 00:46:06,656
standardized, there are default or standard ports

718
00:46:06,688 --> 00:46:09,924
for many applications. For example, most web

719
00:46:09,962 --> 00:46:13,008
applications start on port 80,

720
00:46:13,104 --> 00:46:16,544
so they are accessible on that port from the browser

721
00:46:16,592 --> 00:46:20,852
when you request the application. That means when you type facebook.com

722
00:46:20,906 --> 00:46:24,404
or google.com in the browser, by default,

723
00:46:24,532 --> 00:46:28,184
this request goes to a machine where Facebook or Google application

724
00:46:28,302 --> 00:46:32,536
is running on port 80. So on those machines,

725
00:46:32,648 --> 00:46:36,092
the firewall was configured to unlock the port

726
00:46:36,146 --> 00:46:39,864
80 to accept browser requests. Other applications,

727
00:46:39,912 --> 00:46:44,156
like databases, also have standard ports. Like a MySQL

728
00:46:44,188 --> 00:46:49,568
database is usually accessible on port 3306,

729
00:46:49,734 --> 00:46:53,776
PostgreSql on port 5432, and so

730
00:46:53,798 --> 00:46:57,388
on. So for every application you need a port to

731
00:46:57,414 --> 00:47:01,184
communicate, and each port is unique on a device.

732
00:47:01,312 --> 00:47:04,532
So you can't have two applications listening on the same

733
00:47:04,586 --> 00:47:08,536
port. If you try to start the second application on the same port,

734
00:47:08,638 --> 00:47:12,648
you will get an error which says port already in use.

735
00:47:12,814 --> 00:47:16,712
So the firewall configuration allows a specific combination of

736
00:47:16,766 --> 00:47:21,012
device, IP address and port to be accessed.

737
00:47:21,156 --> 00:47:24,540
So firewall is like a guard that is standing in front of the building

738
00:47:24,610 --> 00:47:28,360
and checks and verifies who can enter which door.

739
00:47:28,440 --> 00:47:32,184
And that configuration is also called port forwarding

740
00:47:32,232 --> 00:47:33,180
configuration.

741
00:47:42,450 --> 00:47:45,902
Now there is some interesting information that we

742
00:47:45,956 --> 00:47:49,658
see displayed here in the Kube system namespace,

743
00:47:49,754 --> 00:47:52,890
as well as in the Kubectl get node output.

744
00:47:52,970 --> 00:47:56,654
Here we see that we have one master node with a version

745
00:47:56,702 --> 00:47:59,922
that we chose to install, and you see that its

746
00:47:59,976 --> 00:48:03,342
status is not ready. So we have one node,

747
00:48:03,406 --> 00:48:06,546
a master node in a cluster which runs some

748
00:48:06,568 --> 00:48:10,194
of the pods. However, it is in the not ready status.

749
00:48:10,322 --> 00:48:13,954
In addition to that, we also see that in the Kube system namespace

750
00:48:14,002 --> 00:48:17,714
we have two pods that are in a pending

751
00:48:17,762 --> 00:48:20,518
state. These are the core DNS pods.

752
00:48:20,614 --> 00:48:24,394
Now there is actually the same reason behind those two

753
00:48:24,432 --> 00:48:27,626
being in a pending state and master node being in

754
00:48:27,648 --> 00:48:31,006
a not ready status. And the reason

755
00:48:31,108 --> 00:48:34,874
for both of these issues is that we need to install what's

756
00:48:34,922 --> 00:48:38,314
called a pod network in kubernetes.

757
00:48:38,442 --> 00:48:42,362
So we've come to a very interesting topic, which is

758
00:48:42,516 --> 00:48:46,462
what is a pod network and how does networking

759
00:48:46,526 --> 00:48:49,806
actually work in Kubernetes? So in the next lectures

760
00:48:49,918 --> 00:48:54,130
we're going to learn everything about networking in kubernetes.

761
00:48:54,490 --> 00:48:58,278
And once we understand that we're going to install

762
00:48:58,444 --> 00:49:02,114
a networking application or a networking layer

763
00:49:02,162 --> 00:49:05,414
in kubernetes that will fix both

764
00:49:05,452 --> 00:49:08,490
of these issues, I hope you're excited about it.

765
00:49:08,560 --> 00:49:10,380
So let's dive in.

766
00:49:13,310 --> 00:49:16,826
The core concept in networking of Kubernetes is

767
00:49:16,848 --> 00:49:20,266
the networking of pods and containers some

768
00:49:20,288 --> 00:49:23,882
of the questions we will answer is how are pods

769
00:49:23,946 --> 00:49:27,374
created? How does pod networking actually look

770
00:49:27,412 --> 00:49:31,450
like? How do pods communicate with each other on the same node

771
00:49:31,530 --> 00:49:35,106
and how they talk to each other across different nodes in

772
00:49:35,128 --> 00:49:39,230
the cluster. First let's see how networking works within the pods

773
00:49:39,310 --> 00:49:43,570
and then we will see how networking works between the pods.

774
00:49:48,710 --> 00:49:52,274
The smallest unit or component is a pod and not

775
00:49:52,312 --> 00:49:56,322
a container. And considering that pod always contains one

776
00:49:56,376 --> 00:50:00,174
main container, for example you might have a pod with postgres

777
00:50:00,222 --> 00:50:04,200
container or elasticsearch container or your own application.

778
00:50:04,570 --> 00:50:08,306
Some people may be asking why the need for abstracting

779
00:50:08,338 --> 00:50:11,942
the container with a pod if there is anyways just one main

780
00:50:11,996 --> 00:50:15,170
application running inside. So in this video I'm going to

781
00:50:15,180 --> 00:50:18,682
explain to you why having a pod as an abstraction over

782
00:50:18,736 --> 00:50:22,346
container is such an important concept in Kubernetes. I'm going to give you

783
00:50:22,368 --> 00:50:25,546
a comparison between pod and container and I will

784
00:50:25,568 --> 00:50:28,842
show you in which cases you would need to have multiple containers

785
00:50:28,906 --> 00:50:32,346
inside one pod and how these containers then will communicate

786
00:50:32,378 --> 00:50:36,094
with each other. At its core, Kubernetes networking has one

787
00:50:36,132 --> 00:50:39,774
important fundamental concept, which is that every pod has

788
00:50:39,812 --> 00:50:43,182
a unique IP address and that ip address is reachable

789
00:50:43,246 --> 00:50:46,958
from all the other pods in the cluster. So that's the main concept.

790
00:50:47,054 --> 00:50:50,726
Now why is it important and valuable to have this pod component with

791
00:50:50,748 --> 00:50:55,154
its own ip address? You see, one main challenge on distributed infrastructure

792
00:50:55,202 --> 00:50:58,854
with multiple servers is how to allocate ports to

793
00:50:58,892 --> 00:51:03,334
services and applications running on servers without getting conflicts.

794
00:51:03,462 --> 00:51:07,322
Since obviously you can only allocate one port once on a single

795
00:51:07,376 --> 00:51:11,162
host with containers, you would soon face

796
00:51:11,216 --> 00:51:14,886
this challenge because this is how container port mapping works.

797
00:51:15,008 --> 00:51:18,702
Let's take for example a postgresql container where

798
00:51:18,756 --> 00:51:22,538
inside the container the postgres application starts

799
00:51:22,634 --> 00:51:26,122
at port 5432. Now when you start containers

800
00:51:26,186 --> 00:51:30,222
directly on your machine, what you do is you bind your host

801
00:51:30,286 --> 00:51:33,518
port to the application port in the container.

802
00:51:33,614 --> 00:51:37,454
And to see that in practice we can start postgres docker container.

803
00:51:37,582 --> 00:51:41,214
So this is the part where we map or we bind

804
00:51:41,262 --> 00:51:45,158
the port on the host to the port of the application running

805
00:51:45,244 --> 00:51:48,566
inside the docker container. So it doesn't have to be

806
00:51:48,588 --> 00:51:52,194
the same port. I can also give it a completely different one. So let's write

807
00:51:52,252 --> 00:51:58,006
5000 and if I execute this command postgres

808
00:51:58,038 --> 00:52:01,850
container started and if we check here with docker ps,

809
00:52:02,270 --> 00:52:06,206
I will see that port 5000 on the

810
00:52:06,228 --> 00:52:09,966
host machine is mapped to this one here. So now

811
00:52:09,988 --> 00:52:13,680
the application is reachable by the host port.

812
00:52:14,450 --> 00:52:17,780
Now that I have one postgres already running,

813
00:52:18,310 --> 00:52:22,114
I could start another postgres container that will

814
00:52:22,152 --> 00:52:26,690
also run at the same port but bind it on a different port

815
00:52:26,760 --> 00:52:30,294
on my host. So this will work

816
00:52:30,332 --> 00:52:33,666
as well. So if I go here now and say docker

817
00:52:33,698 --> 00:52:37,730
ps, I will see two postgres applications

818
00:52:37,810 --> 00:52:41,254
bound to different ports on the host and

819
00:52:41,292 --> 00:52:45,098
this is how containers work. The problem with this is when

820
00:52:45,104 --> 00:52:48,310
you have hundreds of containers running on your servers,

821
00:52:48,470 --> 00:52:52,614
how can you keep track of what ports are still free on the host

822
00:52:52,742 --> 00:52:56,542
to bind them so soon enough? With this type of port

823
00:52:56,596 --> 00:53:00,314
allocation, it will become difficult to have an overview

824
00:53:00,442 --> 00:53:03,946
and the way Kubernetes solves this problem is by abstracting

825
00:53:03,978 --> 00:53:07,502
the containers using pods where pod is like its

826
00:53:07,556 --> 00:53:10,610
own small machine with its own IP address,

827
00:53:10,760 --> 00:53:13,794
usually with one main container running inside.

828
00:53:13,992 --> 00:53:17,614
For example, you might have a pod where postgres container

829
00:53:17,662 --> 00:53:21,042
is running. When a pod is created on a node,

830
00:53:21,186 --> 00:53:25,074
it gets its own network namespace and a virtual ethernet

831
00:53:25,122 --> 00:53:28,802
connection to connect it to the underlying infrastructure

832
00:53:28,866 --> 00:53:32,802
network. So a pod is a host just like your laptop.

833
00:53:32,946 --> 00:53:36,358
Both have IP addresses and a range of ports they can allocate

834
00:53:36,374 --> 00:53:40,042
to its containers. This means you don't have to worry about port

835
00:53:40,096 --> 00:53:43,594
mappings on the server where pod is running and only

836
00:53:43,632 --> 00:53:47,286
inside the pod itself. But since you anyways usually have just one main

837
00:53:47,328 --> 00:53:50,762
container, or sometimes maybe maximum up to six containers

838
00:53:50,826 --> 00:53:54,414
inside a pod, you won't get conflicts there because you have a pretty

839
00:53:54,532 --> 00:53:58,002
good overview of what containers are running inside. This means

840
00:53:58,056 --> 00:54:02,254
that on one server you can have, for example, ten microservice

841
00:54:02,302 --> 00:54:05,726
applications that all run on port 80 80

842
00:54:05,838 --> 00:54:09,694
inside ten different pods. And you won't have any conflicts

843
00:54:09,742 --> 00:54:13,362
because they all run on self contained isolated

844
00:54:13,426 --> 00:54:17,186
machines which are pods. Another reason why pod

845
00:54:17,218 --> 00:54:20,566
abstraction over container is useful is that you

846
00:54:20,588 --> 00:54:24,098
can easily replace the container runtime in Kubernetes. So for

847
00:54:24,124 --> 00:54:27,638
example, if you replace docker runtime with another container runtime

848
00:54:27,734 --> 00:54:31,274
Kubernetes configuration will stay the same because it's all

849
00:54:31,312 --> 00:54:35,162
on the pod level. It means that Kubernetes isn't tied up to any

850
00:54:35,216 --> 00:54:38,686
particular container runtime implementation. Now as

851
00:54:38,708 --> 00:54:42,526
I mentioned at the beginning, sometimes pod might have

852
00:54:42,708 --> 00:54:46,526
two or more containers inside. This is a case when you need to

853
00:54:46,548 --> 00:54:50,546
run a helper or side application to your main application,

854
00:54:50,728 --> 00:54:54,306
like for example for synchronizing when you

855
00:54:54,328 --> 00:54:58,498
have multiple database pods, or for backing up your application

856
00:54:58,664 --> 00:55:02,434
at certain intervals. So it would have this backup sidecar

857
00:55:02,482 --> 00:55:05,606
container within your application container, or it could

858
00:55:05,628 --> 00:55:08,898
be a scheduler or maybe authentication gateway.

859
00:55:08,994 --> 00:55:12,566
So there are many use cases where you might end

860
00:55:12,588 --> 00:55:15,718
up having more than one containers inside a pod.

861
00:55:15,814 --> 00:55:19,574
Now the question is, how do these containers communicate

862
00:55:19,622 --> 00:55:23,542
with each other inside the pod? Remember, pod is an isolated

863
00:55:23,606 --> 00:55:27,194
virtual host with its own network namespace,

864
00:55:27,322 --> 00:55:30,634
and containers inside all run in this network

865
00:55:30,682 --> 00:55:34,014
namespace. This means that containers can talk to each

866
00:55:34,052 --> 00:55:37,182
other via localhost and a port number,

867
00:55:37,316 --> 00:55:40,850
just like when you're running multiple applications on your own laptop.

868
00:55:44,780 --> 00:55:47,896
Also, have you noticed that in a Kubernetes cluster when you

869
00:55:47,918 --> 00:55:51,284
run docker containers, there is this pause container,

870
00:55:51,332 --> 00:55:55,136
always per each pod. These are called sandbox

871
00:55:55,188 --> 00:55:58,652
containers, whose only job is to reserve and hold

872
00:55:58,706 --> 00:56:02,296
the pod's network namespace that's shared by all the containers

873
00:56:02,328 --> 00:56:05,708
in a pod. So post container makes it possible

874
00:56:05,794 --> 00:56:09,644
for the containers to communicate with each other. And also if a container

875
00:56:09,692 --> 00:56:13,504
dies and a new one gets created, pod will stay and

876
00:56:13,542 --> 00:56:16,796
keep its IP address, but know that if the

877
00:56:16,838 --> 00:56:20,404
pod itself dies, it gets recreated and a new pod will

878
00:56:20,442 --> 00:56:22,870
get assigned a different IP address.

879
00:56:30,850 --> 00:56:34,794
Learn how networking works within the pod, how containers

880
00:56:34,842 --> 00:56:38,242
are created, et cetera. Now what about

881
00:56:38,376 --> 00:56:42,222
interpod communication or basically a network where pods

882
00:56:42,286 --> 00:56:45,522
can talk to each other? Well, Kubernetes does not come

883
00:56:45,576 --> 00:56:49,614
with a built in solution for this. Instead, it expects

884
00:56:49,662 --> 00:56:53,358
you to implement a networking solution for pod to

885
00:56:53,384 --> 00:56:56,722
pod communication. And even though Kubernetes doesn't implement

886
00:56:56,786 --> 00:57:00,418
that itself, it has a clear set of rules

887
00:57:00,514 --> 00:57:04,374
of how pod networking should look like in the cluster.

888
00:57:04,502 --> 00:57:07,674
And for the pod networking solution to

889
00:57:07,712 --> 00:57:11,514
work in Kubernetes and to be pluggable to it, basically it has

890
00:57:11,552 --> 00:57:15,434
to implement those definitions and rules.

891
00:57:15,562 --> 00:57:19,018
And that set of rules is CNI

892
00:57:19,114 --> 00:57:22,766
or container networking interface. This is the

893
00:57:22,788 --> 00:57:27,010
same concept as we saw with the container runtime interface. You remember

894
00:57:27,080 --> 00:57:31,314
when we learned that Kubernetes created an interface where

895
00:57:31,352 --> 00:57:34,702
you can basically plug in any container runtime

896
00:57:34,766 --> 00:57:38,534
as long as it implements that interface provided by

897
00:57:38,572 --> 00:57:42,594
Kubernetes. Same way you can deploy and use a networking

898
00:57:42,642 --> 00:57:46,802
plugin if it implements the container networking

899
00:57:46,866 --> 00:57:51,162
interface. Now let's see, what are the requirements for

900
00:57:51,296 --> 00:57:54,902
pod networking solution that network

901
00:57:55,046 --> 00:57:57,946
plugin should implement. First of all,

902
00:57:58,048 --> 00:58:01,834
Kubernetes expects every pod to get its own

903
00:58:01,952 --> 00:58:05,246
unique IP address, and the IP address has to be

904
00:58:05,268 --> 00:58:08,922
unique across the whole cluster, not just the node

905
00:58:08,986 --> 00:58:12,766
where the pod is running. The second one is that pods on

906
00:58:12,788 --> 00:58:16,674
the same node should be able to talk to each other using that

907
00:58:16,712 --> 00:58:19,810
IP address. And the third one is that

908
00:58:19,880 --> 00:58:23,186
pods on different nodes should be able to

909
00:58:23,288 --> 00:58:27,220
also talk to each other using that IP address without

910
00:58:27,610 --> 00:58:30,742
network address translation or net.

911
00:58:30,876 --> 00:58:34,994
So basically, Kubernetes expects a network plugin

912
00:58:35,042 --> 00:58:38,566
to implement a pod network for the

913
00:58:38,588 --> 00:58:41,994
whole cluster on all the nodes talk to each other as

914
00:58:42,032 --> 00:58:45,946
if they were on the same actual network. One thing

915
00:58:45,968 --> 00:58:49,850
that Kubernetes doesn't define or doesn't care about is what

916
00:58:49,920 --> 00:58:53,334
IP address range this network gets

917
00:58:53,392 --> 00:58:57,294
or what IP addresses the pods will get. That's up to the

918
00:58:57,332 --> 00:59:00,414
network plugin to decide. And this model of

919
00:59:00,452 --> 00:59:05,030
how pod networking should look like is called Kubernetes networking

920
00:59:05,130 --> 00:59:08,626
model. And there are many networking solutions out

921
00:59:08,648 --> 00:59:12,302
there or network plugins which implement

922
00:59:12,446 --> 00:59:16,366
this model and fulfill all these requirements,

923
00:59:16,478 --> 00:59:20,674
and some of the most common and popular ones are flannel

924
00:59:20,802 --> 00:59:23,730
psyllium, wavenet from weaveworks,

925
00:59:23,810 --> 00:59:27,026
etc. So how does this all work in practice?

926
00:59:27,138 --> 00:59:31,254
Or how do these networking solutions implement these

927
00:59:31,292 --> 00:59:34,394
requirements? First of all, let's see how pods on the same

928
00:59:34,432 --> 00:59:37,834
node are able to talk to each other directly with their

929
00:59:37,872 --> 00:59:41,846
IP addresses. First of all, let's start with the nodes.

930
00:59:41,958 --> 00:59:45,914
Each node in the cluster will have an IP address from the

931
00:59:45,952 --> 00:59:49,958
IP address range and belong to the same private

932
00:59:50,054 --> 00:59:53,226
network or land. In our case, this is

933
00:59:53,248 --> 00:59:57,074
the VPC in our AWS account, and VPC has

934
00:59:57,112 --> 01:00:00,160
a cider block or IP address range from which.

